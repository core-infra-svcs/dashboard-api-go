/*
Meraki Dashboard API

The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 02 July, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

API version: 1.60.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// PacketCaptureApiService PacketCaptureApi service
type PacketCaptureApiService service

type PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	bulkOrganizationDevicesPacketCaptureCapturesCreate *InlineObject257
}

func (r PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest) BulkOrganizationDevicesPacketCaptureCapturesCreate(bulkOrganizationDevicesPacketCaptureCapturesCreate InlineObject257) PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest {
	r.bulkOrganizationDevicesPacketCaptureCapturesCreate = &bulkOrganizationDevicesPacketCaptureCapturesCreate
	return r
}

func (r PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest) Execute() (*InlineResponse20118, *http.Response, error) {
	return r.ApiService.BulkOrganizationDevicesPacketCaptureCapturesCreateExecute(r)
}

/*
BulkOrganizationDevicesPacketCaptureCapturesCreate Perform a packet capture on multiple devices and store in Meraki Cloud.

Perform a packet capture on multiple devices and store in Meraki Cloud.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest
*/
func (a *PacketCaptureApiService) BulkOrganizationDevicesPacketCaptureCapturesCreate(ctx context.Context, organizationId string) PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest {
	return PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse20118
func (a *PacketCaptureApiService) BulkOrganizationDevicesPacketCaptureCapturesCreateExecute(r PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest) (*InlineResponse20118, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse20118
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.BulkOrganizationDevicesPacketCaptureCapturesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/bulkCreate"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOrganizationDevicesPacketCaptureCapturesCreate == nil {
		return localVarReturnValue, nil, reportError("bulkOrganizationDevicesPacketCaptureCapturesCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOrganizationDevicesPacketCaptureCapturesCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	bulkOrganizationDevicesPacketCaptureCapturesDelete *InlineObject258
}

func (r PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest) BulkOrganizationDevicesPacketCaptureCapturesDelete(bulkOrganizationDevicesPacketCaptureCapturesDelete InlineObject258) PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest {
	r.bulkOrganizationDevicesPacketCaptureCapturesDelete = &bulkOrganizationDevicesPacketCaptureCapturesDelete
	return r
}

func (r PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkOrganizationDevicesPacketCaptureCapturesDeleteExecute(r)
}

/*
BulkOrganizationDevicesPacketCaptureCapturesDelete BulkDelete packet captures from cloud

BulkDelete packet captures from cloud

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest
*/
func (a *PacketCaptureApiService) BulkOrganizationDevicesPacketCaptureCapturesDelete(ctx context.Context, organizationId string) PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest {
	return PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *PacketCaptureApiService) BulkOrganizationDevicesPacketCaptureCapturesDeleteExecute(r PacketCaptureApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.BulkOrganizationDevicesPacketCaptureCapturesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/bulkDelete"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOrganizationDevicesPacketCaptureCapturesDelete == nil {
		return nil, reportError("bulkOrganizationDevicesPacketCaptureCapturesDelete is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOrganizationDevicesPacketCaptureCapturesDelete
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	createOrganizationDevicesPacketCaptureCapture *InlineObject256
}

func (r PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest) CreateOrganizationDevicesPacketCaptureCapture(createOrganizationDevicesPacketCaptureCapture InlineObject256) PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest {
	r.createOrganizationDevicesPacketCaptureCapture = &createOrganizationDevicesPacketCaptureCapture
	return r
}

func (r PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest) Execute() (*InlineResponse200274Items, *http.Response, error) {
	return r.ApiService.CreateOrganizationDevicesPacketCaptureCaptureExecute(r)
}

/*
CreateOrganizationDevicesPacketCaptureCapture Perform a packet capture on a device and store in Meraki Cloud

Perform a packet capture on a device and store in Meraki Cloud. Only a single switch may be chosen per request, while multiple access points are allowed at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest
*/
func (a *PacketCaptureApiService) CreateOrganizationDevicesPacketCaptureCapture(ctx context.Context, organizationId string) PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest {
	return PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200274Items
func (a *PacketCaptureApiService) CreateOrganizationDevicesPacketCaptureCaptureExecute(r PacketCaptureApiCreateOrganizationDevicesPacketCaptureCaptureRequest) (*InlineResponse200274Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200274Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.CreateOrganizationDevicesPacketCaptureCapture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationDevicesPacketCaptureCapture == nil {
		return localVarReturnValue, nil, reportError("createOrganizationDevicesPacketCaptureCapture is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationDevicesPacketCaptureCapture
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	createOrganizationDevicesPacketCaptureSchedule *InlineObject260
}

func (r PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest) CreateOrganizationDevicesPacketCaptureSchedule(createOrganizationDevicesPacketCaptureSchedule InlineObject260) PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest {
	r.createOrganizationDevicesPacketCaptureSchedule = &createOrganizationDevicesPacketCaptureSchedule
	return r
}

func (r PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest) Execute() (*InlineResponse200276Items, *http.Response, error) {
	return r.ApiService.CreateOrganizationDevicesPacketCaptureScheduleExecute(r)
}

/*
CreateOrganizationDevicesPacketCaptureSchedule Create a schedule for packet capture

Create a schedule for packet capture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest
*/
func (a *PacketCaptureApiService) CreateOrganizationDevicesPacketCaptureSchedule(ctx context.Context, organizationId string) PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest {
	return PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200276Items
func (a *PacketCaptureApiService) CreateOrganizationDevicesPacketCaptureScheduleExecute(r PacketCaptureApiCreateOrganizationDevicesPacketCaptureScheduleRequest) (*InlineResponse200276Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200276Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.CreateOrganizationDevicesPacketCaptureSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationDevicesPacketCaptureSchedule == nil {
		return localVarReturnValue, nil, reportError("createOrganizationDevicesPacketCaptureSchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationDevicesPacketCaptureSchedule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiDeleteOrganizationDevicesPacketCaptureCaptureRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	captureId string
}

func (r PacketCaptureApiDeleteOrganizationDevicesPacketCaptureCaptureRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOrganizationDevicesPacketCaptureCaptureExecute(r)
}

/*
DeleteOrganizationDevicesPacketCaptureCapture Delete a single packet capture from cloud using captureId

Delete a single packet capture from cloud using captureId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param captureId Capture ID
 @return PacketCaptureApiDeleteOrganizationDevicesPacketCaptureCaptureRequest
*/
func (a *PacketCaptureApiService) DeleteOrganizationDevicesPacketCaptureCapture(ctx context.Context, organizationId string, captureId string) PacketCaptureApiDeleteOrganizationDevicesPacketCaptureCaptureRequest {
	return PacketCaptureApiDeleteOrganizationDevicesPacketCaptureCaptureRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		captureId: captureId,
	}
}

// Execute executes the request
func (a *PacketCaptureApiService) DeleteOrganizationDevicesPacketCaptureCaptureExecute(r PacketCaptureApiDeleteOrganizationDevicesPacketCaptureCaptureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.DeleteOrganizationDevicesPacketCaptureCapture")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/{captureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"captureId"+"}", url.PathEscape(parameterToString(r.captureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	scheduleId string
	deleteOrganizationDevicesPacketCaptureSchedule *InlineObject263
}

func (r PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest) DeleteOrganizationDevicesPacketCaptureSchedule(deleteOrganizationDevicesPacketCaptureSchedule InlineObject263) PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest {
	r.deleteOrganizationDevicesPacketCaptureSchedule = &deleteOrganizationDevicesPacketCaptureSchedule
	return r
}

func (r PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOrganizationDevicesPacketCaptureScheduleExecute(r)
}

/*
DeleteOrganizationDevicesPacketCaptureSchedule Delete schedule from cloud

Delete schedule from cloud

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param scheduleId Schedule ID
 @return PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest
*/
func (a *PacketCaptureApiService) DeleteOrganizationDevicesPacketCaptureSchedule(ctx context.Context, organizationId string, scheduleId string) PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest {
	return PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
func (a *PacketCaptureApiService) DeleteOrganizationDevicesPacketCaptureScheduleExecute(r PacketCaptureApiDeleteOrganizationDevicesPacketCaptureScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.DeleteOrganizationDevicesPacketCaptureSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/schedules/{scheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scheduleId"+"}", url.PathEscape(parameterToString(r.scheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteOrganizationDevicesPacketCaptureSchedule == nil {
		return nil, reportError("deleteOrganizationDevicesPacketCaptureSchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteOrganizationDevicesPacketCaptureSchedule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PacketCaptureApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	captureId string
}

func (r PacketCaptureApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest) Execute() (*InlineResponse200275, *http.Response, error) {
	return r.ApiService.GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlExecute(r)
}

/*
GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrl Get presigned download URL for given packet capture id

Get presigned download URL for given packet capture id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param captureId Capture ID
 @return PacketCaptureApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest
*/
func (a *PacketCaptureApiService) GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrl(ctx context.Context, organizationId string, captureId string) PacketCaptureApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest {
	return PacketCaptureApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		captureId: captureId,
	}
}

// Execute executes the request
//  @return InlineResponse200275
func (a *PacketCaptureApiService) GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlExecute(r PacketCaptureApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest) (*InlineResponse200275, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200275
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/{captureId}/downloadUrl/generate"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"captureId"+"}", url.PathEscape(parameterToString(r.captureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	captureIds *[]string
	networkIds *[]string
	serials *[]string
	process *[]string
	captureStatus *[]string
	name *[]string
	clientMac *[]string
	notes *string
	deviceName *string
	adminName *string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
}

// Return the packet captures of the specified capture ids
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) CaptureIds(captureIds []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.captureIds = &captureIds
	return r
}

// Return the packet captures of the specified network(s)
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) NetworkIds(networkIds []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.networkIds = &networkIds
	return r
}

// Return the packet captures of the specified device(s)
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) Serials(serials []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.serials = &serials
	return r
}

// Return the packet captures of the specified process
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) Process(process []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.process = &process
	return r
}

// Return the packet captures of the specified capture status
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) CaptureStatus(captureStatus []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.captureStatus = &captureStatus
	return r
}

// Return the packet captures matching the specified name
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) Name(name []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.name = &name
	return r
}

// Return the packet captures matching the specified client macs
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) ClientMac(clientMac []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.clientMac = &clientMac
	return r
}

// Return the packet captures matching the specified notes
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) Notes(notes string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.notes = &notes
	return r
}

// Return the packet captures matching the specified device name
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) DeviceName(deviceName string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.deviceName = &deviceName
	return r
}

// Return the packet captures matching the admin name
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) AdminName(adminName string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.adminName = &adminName
	return r
}

// The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) PerPage(perPage int32) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) StartingAfter(startingAfter string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) EndingBefore(endingBefore string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;descending&#39;.
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) SortOrder(sortOrder string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) Execute() (*InlineResponse200274, *http.Response, error) {
	return r.ApiService.GetOrganizationDevicesPacketCaptureCapturesExecute(r)
}

/*
GetOrganizationDevicesPacketCaptureCaptures List Packet Captures

List Packet Captures

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest
*/
func (a *PacketCaptureApiService) GetOrganizationDevicesPacketCaptureCaptures(ctx context.Context, organizationId string) PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	return PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200274
func (a *PacketCaptureApiService) GetOrganizationDevicesPacketCaptureCapturesExecute(r PacketCaptureApiGetOrganizationDevicesPacketCaptureCapturesRequest) (*InlineResponse200274, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200274
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.GetOrganizationDevicesPacketCaptureCaptures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.captureIds != nil {
		localVarQueryParams.Add("captureIds", parameterToString(*r.captureIds, "csv"))
	}
	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.process != nil {
		localVarQueryParams.Add("process", parameterToString(*r.process, "csv"))
	}
	if r.captureStatus != nil {
		localVarQueryParams.Add("captureStatus", parameterToString(*r.captureStatus, "csv"))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, "csv"))
	}
	if r.clientMac != nil {
		localVarQueryParams.Add("clientMac", parameterToString(*r.clientMac, "csv"))
	}
	if r.notes != nil {
		localVarQueryParams.Add("notes", parameterToString(*r.notes, ""))
	}
	if r.deviceName != nil {
		localVarQueryParams.Add("deviceName", parameterToString(*r.deviceName, ""))
	}
	if r.adminName != nil {
		localVarQueryParams.Add("adminName", parameterToString(*r.adminName, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	scheduleIds *[]string
	networkIds *[]string
	deviceIds *[]string
}

// Return the packet captures schedules of the specified packet capture schedule ids
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest) ScheduleIds(scheduleIds []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest {
	r.scheduleIds = &scheduleIds
	return r
}

// Return the scheduled packet captures of the specified network(s)
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest) NetworkIds(networkIds []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest {
	r.networkIds = &networkIds
	return r
}

// Return the scheduled packet captures of the specified device(s)
func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest) DeviceIds(deviceIds []string) PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest {
	r.deviceIds = &deviceIds
	return r
}

func (r PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest) Execute() (*InlineResponse200276, *http.Response, error) {
	return r.ApiService.GetOrganizationDevicesPacketCaptureSchedulesExecute(r)
}

/*
GetOrganizationDevicesPacketCaptureSchedules List the Packet Capture Schedules

List the Packet Capture Schedules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest
*/
func (a *PacketCaptureApiService) GetOrganizationDevicesPacketCaptureSchedules(ctx context.Context, organizationId string) PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest {
	return PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200276
func (a *PacketCaptureApiService) GetOrganizationDevicesPacketCaptureSchedulesExecute(r PacketCaptureApiGetOrganizationDevicesPacketCaptureSchedulesRequest) (*InlineResponse200276, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200276
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.GetOrganizationDevicesPacketCaptureSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/schedules"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.scheduleIds != nil {
		localVarQueryParams.Add("scheduleIds", parameterToString(*r.scheduleIds, "csv"))
	}
	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.deviceIds != nil {
		localVarQueryParams.Add("deviceIds", parameterToString(*r.deviceIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	reorderOrganizationDevicesPacketCaptureSchedules *InlineObject261
}

func (r PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest) ReorderOrganizationDevicesPacketCaptureSchedules(reorderOrganizationDevicesPacketCaptureSchedules InlineObject261) PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest {
	r.reorderOrganizationDevicesPacketCaptureSchedules = &reorderOrganizationDevicesPacketCaptureSchedules
	return r
}

func (r PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest) Execute() (*InlineResponse200277, *http.Response, error) {
	return r.ApiService.ReorderOrganizationDevicesPacketCaptureSchedulesExecute(r)
}

/*
ReorderOrganizationDevicesPacketCaptureSchedules Bulk update priorities of pcap schedules

Bulk update priorities of pcap schedules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest
*/
func (a *PacketCaptureApiService) ReorderOrganizationDevicesPacketCaptureSchedules(ctx context.Context, organizationId string) PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest {
	return PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200277
func (a *PacketCaptureApiService) ReorderOrganizationDevicesPacketCaptureSchedulesExecute(r PacketCaptureApiReorderOrganizationDevicesPacketCaptureSchedulesRequest) (*InlineResponse200277, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200277
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.ReorderOrganizationDevicesPacketCaptureSchedules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/schedules/reorder"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.reorderOrganizationDevicesPacketCaptureSchedules == nil {
		return localVarReturnValue, nil, reportError("reorderOrganizationDevicesPacketCaptureSchedules is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reorderOrganizationDevicesPacketCaptureSchedules
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	captureId string
	stopOrganizationDevicesPacketCaptureCapture *InlineObject259
}

func (r PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest) StopOrganizationDevicesPacketCaptureCapture(stopOrganizationDevicesPacketCaptureCapture InlineObject259) PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest {
	r.stopOrganizationDevicesPacketCaptureCapture = &stopOrganizationDevicesPacketCaptureCapture
	return r
}

func (r PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest) Execute() (*InlineResponse200274Items, *http.Response, error) {
	return r.ApiService.StopOrganizationDevicesPacketCaptureCaptureExecute(r)
}

/*
StopOrganizationDevicesPacketCaptureCapture Stop a specific packet capture (not supported for Catalyst devices)

Stop a specific packet capture (not supported for Catalyst devices)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param captureId Capture ID
 @return PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest
*/
func (a *PacketCaptureApiService) StopOrganizationDevicesPacketCaptureCapture(ctx context.Context, organizationId string, captureId string) PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest {
	return PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		captureId: captureId,
	}
}

// Execute executes the request
//  @return InlineResponse200274Items
func (a *PacketCaptureApiService) StopOrganizationDevicesPacketCaptureCaptureExecute(r PacketCaptureApiStopOrganizationDevicesPacketCaptureCaptureRequest) (*InlineResponse200274Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200274Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.StopOrganizationDevicesPacketCaptureCapture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/{captureId}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"captureId"+"}", url.PathEscape(parameterToString(r.captureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopOrganizationDevicesPacketCaptureCapture == nil {
		return localVarReturnValue, nil, reportError("stopOrganizationDevicesPacketCaptureCapture is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopOrganizationDevicesPacketCaptureCapture
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest struct {
	ctx context.Context
	ApiService *PacketCaptureApiService
	organizationId string
	scheduleId string
	updateOrganizationDevicesPacketCaptureSchedule *InlineObject262
}

func (r PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest) UpdateOrganizationDevicesPacketCaptureSchedule(updateOrganizationDevicesPacketCaptureSchedule InlineObject262) PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest {
	r.updateOrganizationDevicesPacketCaptureSchedule = &updateOrganizationDevicesPacketCaptureSchedule
	return r
}

func (r PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest) Execute() (*InlineResponse200276Items, *http.Response, error) {
	return r.ApiService.UpdateOrganizationDevicesPacketCaptureScheduleExecute(r)
}

/*
UpdateOrganizationDevicesPacketCaptureSchedule Update a schedule for packet capture

Update a schedule for packet capture

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param scheduleId Schedule ID
 @return PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest
*/
func (a *PacketCaptureApiService) UpdateOrganizationDevicesPacketCaptureSchedule(ctx context.Context, organizationId string, scheduleId string) PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest {
	return PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		scheduleId: scheduleId,
	}
}

// Execute executes the request
//  @return InlineResponse200276Items
func (a *PacketCaptureApiService) UpdateOrganizationDevicesPacketCaptureScheduleExecute(r PacketCaptureApiUpdateOrganizationDevicesPacketCaptureScheduleRequest) (*InlineResponse200276Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200276Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PacketCaptureApiService.UpdateOrganizationDevicesPacketCaptureSchedule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/schedules/{scheduleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scheduleId"+"}", url.PathEscape(parameterToString(r.scheduleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOrganizationDevicesPacketCaptureSchedule == nil {
		return localVarReturnValue, nil, reportError("updateOrganizationDevicesPacketCaptureSchedule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationDevicesPacketCaptureSchedule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
