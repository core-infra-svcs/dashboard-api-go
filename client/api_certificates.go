/*
Meraki Dashboard API

The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 02 July, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

API version: 1.60.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CertificatesApiService CertificatesApi service
type CertificatesApiService service

type CertificatesApiCreateOrganizationWirelessDevicesRadsecCertificatesAuthorityRequest struct {
	ctx context.Context
	ApiService *CertificatesApiService
	organizationId string
}

func (r CertificatesApiCreateOrganizationWirelessDevicesRadsecCertificatesAuthorityRequest) Execute() (*InlineResponse200359, *http.Response, error) {
	return r.ApiService.CreateOrganizationWirelessDevicesRadsecCertificatesAuthorityExecute(r)
}

/*
CreateOrganizationWirelessDevicesRadsecCertificatesAuthority Create an organization's RADSEC device Certificate Authority (CA)

Create an organization's RADSEC device Certificate Authority (CA). Call this endpoint when turning on RADSEC in the firmware for the first time. Calling this endpoint starts an asynchronous process to generate the CA; call GET afterwards to retrieve the contents of the CA. Note this CA is generated and controlled by Meraki. Subsequent calls will not generate a new CA.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CertificatesApiCreateOrganizationWirelessDevicesRadsecCertificatesAuthorityRequest
*/
func (a *CertificatesApiService) CreateOrganizationWirelessDevicesRadsecCertificatesAuthority(ctx context.Context, organizationId string) CertificatesApiCreateOrganizationWirelessDevicesRadsecCertificatesAuthorityRequest {
	return CertificatesApiCreateOrganizationWirelessDevicesRadsecCertificatesAuthorityRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200359
func (a *CertificatesApiService) CreateOrganizationWirelessDevicesRadsecCertificatesAuthorityExecute(r CertificatesApiCreateOrganizationWirelessDevicesRadsecCertificatesAuthorityRequest) (*InlineResponse200359, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200359
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesApiService.CreateOrganizationWirelessDevicesRadsecCertificatesAuthority")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wireless/devices/radsec/certificates/authorities"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest struct {
	ctx context.Context
	ApiService *CertificatesApiService
	organizationId string
	certificateAuthorityIds *[]string
}

// Optional parameter to filter CAs by one or more CA IDs. All returned CAs will have an ID that is an exact match.
func (r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest) CertificateAuthorityIds(certificateAuthorityIds []string) CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest {
	r.certificateAuthorityIds = &certificateAuthorityIds
	return r
}

func (r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest) Execute() ([]InlineResponse200358, *http.Response, error) {
	return r.ApiService.GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesExecute(r)
}

/*
GetOrganizationWirelessDevicesRadsecCertificatesAuthorities Query for details on the organization's RADSEC device Certificate Authority certificates (CAs)

Query for details on the organization's RADSEC device Certificate Authority certificates (CAs). The primary CA signs all the certificates that devices present when establishing a secure connection to RADIUS servers via RADSEC protocol. This API returns an array of the status of all of the CAs as well as their contents, if they've been generated. An organization will have at most one CA unless the CA is being rotated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest
*/
func (a *CertificatesApiService) GetOrganizationWirelessDevicesRadsecCertificatesAuthorities(ctx context.Context, organizationId string) CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest {
	return CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return []InlineResponse200358
func (a *CertificatesApiService) GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesExecute(r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest) ([]InlineResponse200358, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200358
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesApiService.GetOrganizationWirelessDevicesRadsecCertificatesAuthorities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wireless/devices/radsec/certificates/authorities"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.certificateAuthorityIds != nil {
		localVarQueryParams.Add("certificateAuthorityIds", parameterToString(*r.certificateAuthorityIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest struct {
	ctx context.Context
	ApiService *CertificatesApiService
	organizationId string
	certificateAuthorityIds *[]string
}

// Optional parameter to filter CAs by one or more CA IDs. All returned CAs will have an ID that is an exact match.
func (r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest) CertificateAuthorityIds(certificateAuthorityIds []string) CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest {
	r.certificateAuthorityIds = &certificateAuthorityIds
	return r
}

func (r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest) Execute() (*InlineResponse200360, *http.Response, error) {
	return r.ApiService.GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsExecute(r)
}

/*
GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrls Query for certificate revocation list (CRL) for the organization's RADSEC device Certificate Authorities (CAs).

Query for certificate revocation list (CRL) for the organization's RADSEC device Certificate Authorities (CAs).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest
*/
func (a *CertificatesApiService) GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrls(ctx context.Context, organizationId string) CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest {
	return CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200360
func (a *CertificatesApiService) GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsExecute(r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsRequest) (*InlineResponse200360, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200360
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesApiService.GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wireless/devices/radsec/certificates/authorities/crls"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.certificateAuthorityIds != nil {
		localVarQueryParams.Add("certificateAuthorityIds", parameterToString(*r.certificateAuthorityIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest struct {
	ctx context.Context
	ApiService *CertificatesApiService
	organizationId string
	certificateAuthorityIds *[]string
}

// Parameter to filter CAs by one or more CA IDs. All returned CAs will have an ID that is an exact match.
func (r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest) CertificateAuthorityIds(certificateAuthorityIds []string) CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest {
	r.certificateAuthorityIds = &certificateAuthorityIds
	return r
}

func (r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest) Execute() (*InlineResponse200360, *http.Response, error) {
	return r.ApiService.GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasExecute(r)
}

/*
GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltas Query for all delta certificate revocation list (CRL) for the organization's RADSEC device Certificate Authority (CA) with the given id.

Query for all delta certificate revocation list (CRL) for the organization's RADSEC device Certificate Authority (CA) with the given id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest
*/
func (a *CertificatesApiService) GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltas(ctx context.Context, organizationId string) CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest {
	return CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200360
func (a *CertificatesApiService) GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasExecute(r CertificatesApiGetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltasRequest) (*InlineResponse200360, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200360
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesApiService.GetOrganizationWirelessDevicesRadsecCertificatesAuthoritiesCrlsDeltas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wireless/devices/radsec/certificates/authorities/crls/deltas"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.certificateAuthorityIds != nil {
		localVarQueryParams.Add("certificateAuthorityIds", parameterToString(*r.certificateAuthorityIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest struct {
	ctx context.Context
	ApiService *CertificatesApiService
	organizationId string
	updateOrganizationWirelessDevicesRadsecCertificatesAuthorities *InlineObject301
}

func (r CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest) UpdateOrganizationWirelessDevicesRadsecCertificatesAuthorities(updateOrganizationWirelessDevicesRadsecCertificatesAuthorities InlineObject301) CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest {
	r.updateOrganizationWirelessDevicesRadsecCertificatesAuthorities = &updateOrganizationWirelessDevicesRadsecCertificatesAuthorities
	return r
}

func (r CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest) Execute() (*InlineResponse200359, *http.Response, error) {
	return r.ApiService.UpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesExecute(r)
}

/*
UpdateOrganizationWirelessDevicesRadsecCertificatesAuthorities Update an organization's RADSEC device Certificate Authority (CA) state

Update an organization's RADSEC device Certificate Authority (CA) state. Note this CA is generated and controlled by Meraki. Call this endpoint to update the state to "trusted", at which point Meraki will generate device certificates. "trusted" means the CA is placed on your RADSEC server(s) and devices establishing a secure connection using certs signed by this CA will pass verification.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest
*/
func (a *CertificatesApiService) UpdateOrganizationWirelessDevicesRadsecCertificatesAuthorities(ctx context.Context, organizationId string) CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest {
	return CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200359
func (a *CertificatesApiService) UpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesExecute(r CertificatesApiUpdateOrganizationWirelessDevicesRadsecCertificatesAuthoritiesRequest) (*InlineResponse200359, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200359
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CertificatesApiService.UpdateOrganizationWirelessDevicesRadsecCertificatesAuthorities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wireless/devices/radsec/certificates/authorities"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationWirelessDevicesRadsecCertificatesAuthorities
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
