/*
Meraki Dashboard API

The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 05 February, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

API version: 1.55.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// AlertsApiService AlertsApi service
type AlertsApiService service

type AlertsApiCreateNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
	createNetworkSensorAlertsProfile *InlineObject115
}

func (r AlertsApiCreateNetworkSensorAlertsProfileRequest) CreateNetworkSensorAlertsProfile(createNetworkSensorAlertsProfile InlineObject115) AlertsApiCreateNetworkSensorAlertsProfileRequest {
	r.createNetworkSensorAlertsProfile = &createNetworkSensorAlertsProfile
	return r
}

func (r AlertsApiCreateNetworkSensorAlertsProfileRequest) Execute() (*InlineResponse200116, *http.Response, error) {
	return r.ApiService.CreateNetworkSensorAlertsProfileExecute(r)
}

/*
CreateNetworkSensorAlertsProfile Creates a sensor alert profile for a network.

Creates a sensor alert profile for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiCreateNetworkSensorAlertsProfileRequest
*/
func (a *AlertsApiService) CreateNetworkSensorAlertsProfile(ctx context.Context, networkId string) AlertsApiCreateNetworkSensorAlertsProfileRequest {
	return AlertsApiCreateNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return InlineResponse200116
func (a *AlertsApiService) CreateNetworkSensorAlertsProfileExecute(r AlertsApiCreateNetworkSensorAlertsProfileRequest) (*InlineResponse200116, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200116
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.CreateNetworkSensorAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createNetworkSensorAlertsProfile == nil {
		return localVarReturnValue, nil, reportError("createNetworkSensorAlertsProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNetworkSensorAlertsProfile
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiCreateOrganizationAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	createOrganizationAlertsProfile *InlineObject215
}

func (r AlertsApiCreateOrganizationAlertsProfileRequest) CreateOrganizationAlertsProfile(createOrganizationAlertsProfile InlineObject215) AlertsApiCreateOrganizationAlertsProfileRequest {
	r.createOrganizationAlertsProfile = &createOrganizationAlertsProfile
	return r
}

func (r AlertsApiCreateOrganizationAlertsProfileRequest) Execute() (*InlineResponse200214, *http.Response, error) {
	return r.ApiService.CreateOrganizationAlertsProfileExecute(r)
}

/*
CreateOrganizationAlertsProfile Create an organization-wide alert configuration

Create an organization-wide alert configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiCreateOrganizationAlertsProfileRequest
*/
func (a *AlertsApiService) CreateOrganizationAlertsProfile(ctx context.Context, organizationId string) AlertsApiCreateOrganizationAlertsProfileRequest {
	return AlertsApiCreateOrganizationAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200214
func (a *AlertsApiService) CreateOrganizationAlertsProfileExecute(r AlertsApiCreateOrganizationAlertsProfileRequest) (*InlineResponse200214, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200214
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.CreateOrganizationAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationAlertsProfile == nil {
		return localVarReturnValue, nil, reportError("createOrganizationAlertsProfile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationAlertsProfile
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiDeleteNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
	id string
}

func (r AlertsApiDeleteNetworkSensorAlertsProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNetworkSensorAlertsProfileExecute(r)
}

/*
DeleteNetworkSensorAlertsProfile Deletes a sensor alert profile from a network.

Deletes a sensor alert profile from a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @param id ID
 @return AlertsApiDeleteNetworkSensorAlertsProfileRequest
*/
func (a *AlertsApiService) DeleteNetworkSensorAlertsProfile(ctx context.Context, networkId string, id string) AlertsApiDeleteNetworkSensorAlertsProfileRequest {
	return AlertsApiDeleteNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
		id: id,
	}
}

// Execute executes the request
func (a *AlertsApiService) DeleteNetworkSensorAlertsProfileExecute(r AlertsApiDeleteNetworkSensorAlertsProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.DeleteNetworkSensorAlertsProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsApiDeleteOrganizationAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	alertConfigId string
}

func (r AlertsApiDeleteOrganizationAlertsProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOrganizationAlertsProfileExecute(r)
}

/*
DeleteOrganizationAlertsProfile Removes an organization-wide alert config

Removes an organization-wide alert config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param alertConfigId Alert config ID
 @return AlertsApiDeleteOrganizationAlertsProfileRequest
*/
func (a *AlertsApiService) DeleteOrganizationAlertsProfile(ctx context.Context, organizationId string, alertConfigId string) AlertsApiDeleteOrganizationAlertsProfileRequest {
	return AlertsApiDeleteOrganizationAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		alertConfigId: alertConfigId,
	}
}

// Execute executes the request
func (a *AlertsApiService) DeleteOrganizationAlertsProfileExecute(r AlertsApiDeleteOrganizationAlertsProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.DeleteOrganizationAlertsProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles/{alertConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertConfigId"+"}", url.PathEscape(parameterToString(r.alertConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsApiDismissOrganizationAssuranceAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	dismissOrganizationAssuranceAlerts *InlineObject230
}

func (r AlertsApiDismissOrganizationAssuranceAlertsRequest) DismissOrganizationAssuranceAlerts(dismissOrganizationAssuranceAlerts InlineObject230) AlertsApiDismissOrganizationAssuranceAlertsRequest {
	r.dismissOrganizationAssuranceAlerts = &dismissOrganizationAssuranceAlerts
	return r
}

func (r AlertsApiDismissOrganizationAssuranceAlertsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DismissOrganizationAssuranceAlertsExecute(r)
}

/*
DismissOrganizationAssuranceAlerts Dismiss health alerts

Dismiss health alerts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiDismissOrganizationAssuranceAlertsRequest
*/
func (a *AlertsApiService) DismissOrganizationAssuranceAlerts(ctx context.Context, organizationId string) AlertsApiDismissOrganizationAssuranceAlertsRequest {
	return AlertsApiDismissOrganizationAssuranceAlertsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *AlertsApiService) DismissOrganizationAssuranceAlertsExecute(r AlertsApiDismissOrganizationAssuranceAlertsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.DismissOrganizationAssuranceAlerts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/dismiss"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dismissOrganizationAssuranceAlerts == nil {
		return nil, reportError("dismissOrganizationAssuranceAlerts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dismissOrganizationAssuranceAlerts
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsApiGetNetworkAlertsHistoryRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
	perPage *int32
	startingAfter *string
	endingBefore *string
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
func (r AlertsApiGetNetworkAlertsHistoryRequest) PerPage(perPage int32) AlertsApiGetNetworkAlertsHistoryRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetNetworkAlertsHistoryRequest) StartingAfter(startingAfter string) AlertsApiGetNetworkAlertsHistoryRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetNetworkAlertsHistoryRequest) EndingBefore(endingBefore string) AlertsApiGetNetworkAlertsHistoryRequest {
	r.endingBefore = &endingBefore
	return r
}

func (r AlertsApiGetNetworkAlertsHistoryRequest) Execute() ([]InlineResponse20048, *http.Response, error) {
	return r.ApiService.GetNetworkAlertsHistoryExecute(r)
}

/*
GetNetworkAlertsHistory Return the alert history for this network

Return the alert history for this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiGetNetworkAlertsHistoryRequest
*/
func (a *AlertsApiService) GetNetworkAlertsHistory(ctx context.Context, networkId string) AlertsApiGetNetworkAlertsHistoryRequest {
	return AlertsApiGetNetworkAlertsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []InlineResponse20048
func (a *AlertsApiService) GetNetworkAlertsHistoryExecute(r AlertsApiGetNetworkAlertsHistoryRequest) ([]InlineResponse20048, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse20048
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetNetworkAlertsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/alerts/history"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetNetworkAlertsSettingsRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
}

func (r AlertsApiGetNetworkAlertsSettingsRequest) Execute() (*InlineResponse20049, *http.Response, error) {
	return r.ApiService.GetNetworkAlertsSettingsExecute(r)
}

/*
GetNetworkAlertsSettings Return the alert configuration for this network

Return the alert configuration for this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiGetNetworkAlertsSettingsRequest
*/
func (a *AlertsApiService) GetNetworkAlertsSettings(ctx context.Context, networkId string) AlertsApiGetNetworkAlertsSettingsRequest {
	return AlertsApiGetNetworkAlertsSettingsRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return InlineResponse20049
func (a *AlertsApiService) GetNetworkAlertsSettingsExecute(r AlertsApiGetNetworkAlertsSettingsRequest) (*InlineResponse20049, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse20049
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetNetworkAlertsSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/alerts/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetNetworkHealthAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
}

func (r AlertsApiGetNetworkHealthAlertsRequest) Execute() ([]InlineResponse200105, *http.Response, error) {
	return r.ApiService.GetNetworkHealthAlertsExecute(r)
}

/*
GetNetworkHealthAlerts Return all global alerts on this network

Return all global alerts on this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiGetNetworkHealthAlertsRequest

Deprecated
*/
func (a *AlertsApiService) GetNetworkHealthAlerts(ctx context.Context, networkId string) AlertsApiGetNetworkHealthAlertsRequest {
	return AlertsApiGetNetworkHealthAlertsRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []InlineResponse200105
// Deprecated
func (a *AlertsApiService) GetNetworkHealthAlertsExecute(r AlertsApiGetNetworkHealthAlertsRequest) ([]InlineResponse200105, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200105
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetNetworkHealthAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/health/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
}

func (r AlertsApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest) Execute() (*InlineResponse200114, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsCurrentOverviewByMetricExecute(r)
}

/*
GetNetworkSensorAlertsCurrentOverviewByMetric Return an overview of currently alerting sensors by metric

Return an overview of currently alerting sensors by metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest
*/
func (a *AlertsApiService) GetNetworkSensorAlertsCurrentOverviewByMetric(ctx context.Context, networkId string) AlertsApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest {
	return AlertsApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return InlineResponse200114
func (a *AlertsApiService) GetNetworkSensorAlertsCurrentOverviewByMetricExecute(r AlertsApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest) (*InlineResponse200114, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200114
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetNetworkSensorAlertsCurrentOverviewByMetric")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/current/overview/byMetric"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
	t0 *string
	t1 *string
	timespan *float32
	interval *int32
}

// The beginning of the timespan for the data. The maximum lookback period is 731 days from today.
func (r AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest) T0(t0 string) AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 366 days after t0.
func (r AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest) T1(t1 string) AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 366 days. The default is 7 days. If interval is provided, the timespan will be autocalculated.
func (r AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest) Timespan(timespan float32) AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.timespan = &timespan
	return r
}

// The time interval in seconds for returned data. The valid intervals are: 900, 3600, 86400, 604800, 2592000. The default is 604800. Interval is calculated if time params are provided.
func (r AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest) Interval(interval int32) AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.interval = &interval
	return r
}

func (r AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest) Execute() ([]InlineResponse200115, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsOverviewByMetricExecute(r)
}

/*
GetNetworkSensorAlertsOverviewByMetric Return an overview of alert occurrences over a timespan, by metric

Return an overview of alert occurrences over a timespan, by metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest
*/
func (a *AlertsApiService) GetNetworkSensorAlertsOverviewByMetric(ctx context.Context, networkId string) AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest {
	return AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []InlineResponse200115
func (a *AlertsApiService) GetNetworkSensorAlertsOverviewByMetricExecute(r AlertsApiGetNetworkSensorAlertsOverviewByMetricRequest) ([]InlineResponse200115, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200115
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetNetworkSensorAlertsOverviewByMetric")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/overview/byMetric"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
	id string
}

func (r AlertsApiGetNetworkSensorAlertsProfileRequest) Execute() (*InlineResponse200116, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsProfileExecute(r)
}

/*
GetNetworkSensorAlertsProfile Show details of a sensor alert profile for a network.

Show details of a sensor alert profile for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @param id ID
 @return AlertsApiGetNetworkSensorAlertsProfileRequest
*/
func (a *AlertsApiService) GetNetworkSensorAlertsProfile(ctx context.Context, networkId string, id string) AlertsApiGetNetworkSensorAlertsProfileRequest {
	return AlertsApiGetNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
		id: id,
	}
}

// Execute executes the request
//  @return InlineResponse200116
func (a *AlertsApiService) GetNetworkSensorAlertsProfileExecute(r AlertsApiGetNetworkSensorAlertsProfileRequest) (*InlineResponse200116, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200116
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetNetworkSensorAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetNetworkSensorAlertsProfilesRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
}

func (r AlertsApiGetNetworkSensorAlertsProfilesRequest) Execute() ([]InlineResponse200116, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsProfilesExecute(r)
}

/*
GetNetworkSensorAlertsProfiles Lists all sensor alert profiles for a network.

Lists all sensor alert profiles for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiGetNetworkSensorAlertsProfilesRequest
*/
func (a *AlertsApiService) GetNetworkSensorAlertsProfiles(ctx context.Context, networkId string) AlertsApiGetNetworkSensorAlertsProfilesRequest {
	return AlertsApiGetNetworkSensorAlertsProfilesRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []InlineResponse200116
func (a *AlertsApiService) GetNetworkSensorAlertsProfilesExecute(r AlertsApiGetNetworkSensorAlertsProfilesRequest) ([]InlineResponse200116, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200116
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetNetworkSensorAlertsProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetOrganizationAlertsProfilesRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
}

func (r AlertsApiGetOrganizationAlertsProfilesRequest) Execute() ([]InlineResponse200214, *http.Response, error) {
	return r.ApiService.GetOrganizationAlertsProfilesExecute(r)
}

/*
GetOrganizationAlertsProfiles List all organization-wide alert configurations

List all organization-wide alert configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiGetOrganizationAlertsProfilesRequest
*/
func (a *AlertsApiService) GetOrganizationAlertsProfiles(ctx context.Context, organizationId string) AlertsApiGetOrganizationAlertsProfilesRequest {
	return AlertsApiGetOrganizationAlertsProfilesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return []InlineResponse200214
func (a *AlertsApiService) GetOrganizationAlertsProfilesExecute(r AlertsApiGetOrganizationAlertsProfilesRequest) ([]InlineResponse200214, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200214
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetOrganizationAlertsProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetOrganizationAssuranceAlertRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	id string
}

func (r AlertsApiGetOrganizationAssuranceAlertRequest) Execute() (*InlineResponse200232, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertExecute(r)
}

/*
GetOrganizationAssuranceAlert Return a singular Health Alert by its id

Return a singular Health Alert by its id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param id ID
 @return AlertsApiGetOrganizationAssuranceAlertRequest
*/
func (a *AlertsApiService) GetOrganizationAssuranceAlert(ctx context.Context, organizationId string, id string) AlertsApiGetOrganizationAssuranceAlertRequest {
	return AlertsApiGetOrganizationAssuranceAlertRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		id: id,
	}
}

// Execute executes the request
//  @return InlineResponse200232
func (a *AlertsApiService) GetOrganizationAssuranceAlertExecute(r AlertsApiGetOrganizationAssuranceAlertRequest) (*InlineResponse200232, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200232
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetOrganizationAssuranceAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetOrganizationAssuranceAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	sortBy *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 4 - 300. Default is 30.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) PerPage(perPage int32) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) StartingAfter(startingAfter string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) EndingBefore(endingBefore string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) SortOrder(sortOrder string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts by network ids.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) NetworkId(networkId string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter by severity type.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Severity(severity string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Types(types []string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) TsStart(tsStart time.Time) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) TsEnd(tsEnd time.Time) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Category(category string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.category = &category
	return r
}

// Optional parameter to set column to sort by.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) SortBy(sortBy string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Serials(serials []string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) DeviceTypes(deviceTypes []string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) DeviceTags(deviceTags []string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Active(active bool) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Dismissed(dismissed bool) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Resolved(resolved bool) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsApiGetOrganizationAssuranceAlertsRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsApiGetOrganizationAssuranceAlertsRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsApiGetOrganizationAssuranceAlertsRequest) Execute() ([]InlineResponse200232, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsExecute(r)
}

/*
GetOrganizationAssuranceAlerts Return all health alerts for an organization

Return all health alerts for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiGetOrganizationAssuranceAlertsRequest
*/
func (a *AlertsApiService) GetOrganizationAssuranceAlerts(ctx context.Context, organizationId string) AlertsApiGetOrganizationAssuranceAlertsRequest {
	return AlertsApiGetOrganizationAssuranceAlertsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return []InlineResponse200232
func (a *AlertsApiService) GetOrganizationAssuranceAlertsExecute(r AlertsApiGetOrganizationAssuranceAlertsRequest) ([]InlineResponse200232, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200232
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetOrganizationAssuranceAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.tsStart != nil {
		localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	}
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	if r.deviceTags != nil {
		localVarQueryParams.Add("deviceTags", parameterToString(*r.deviceTags, "csv"))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.dismissed != nil {
		localVarQueryParams.Add("dismissed", parameterToString(*r.dismissed, ""))
	}
	if r.resolved != nil {
		localVarQueryParams.Add("resolved", parameterToString(*r.resolved, ""))
	}
	if r.suppressAlertsForOfflineNodes != nil {
		localVarQueryParams.Add("suppressAlertsForOfflineNodes", parameterToString(*r.suppressAlertsForOfflineNodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetOrganizationAssuranceAlertsOverviewRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// Optional parameter to filter alerts overview by network ids.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) NetworkId(networkId string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Severity(severity string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Types(types []string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) TsStart(tsStart time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) TsEnd(tsEnd time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Category(category string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.category = &category
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Serials(serials []string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) DeviceTypes(deviceTypes []string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) DeviceTags(deviceTags []string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Active(active bool) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Dismissed(dismissed bool) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Resolved(resolved bool) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) Execute() (*InlineResponse200233, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverview Return overview of active health alerts for an organization

Return overview of active health alerts for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiGetOrganizationAssuranceAlertsOverviewRequest
*/
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverview(ctx context.Context, organizationId string) AlertsApiGetOrganizationAssuranceAlertsOverviewRequest {
	return AlertsApiGetOrganizationAssuranceAlertsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200233
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverviewExecute(r AlertsApiGetOrganizationAssuranceAlertsOverviewRequest) (*InlineResponse200233, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200233
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetOrganizationAssuranceAlertsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.tsStart != nil {
		localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	}
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	if r.deviceTags != nil {
		localVarQueryParams.Add("deviceTags", parameterToString(*r.deviceTags, "csv"))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.dismissed != nil {
		localVarQueryParams.Add("dismissed", parameterToString(*r.dismissed, ""))
	}
	if r.resolved != nil {
		localVarQueryParams.Add("resolved", parameterToString(*r.resolved, ""))
	}
	if r.suppressAlertsForOfflineNodes != nil {
		localVarQueryParams.Add("suppressAlertsForOfflineNodes", parameterToString(*r.suppressAlertsForOfflineNodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) PerPage(perPage int32) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) StartingAfter(startingAfter string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) EndingBefore(endingBefore string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) SortOrder(sortOrder string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts overview by network id.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) NetworkId(networkId string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Severity(severity string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Types(types []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) TsStart(tsStart time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) TsEnd(tsEnd time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Category(category string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.category = &category
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Serials(serials []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) DeviceTypes(deviceTypes []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) DeviceTags(deviceTags []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Active(active bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Dismissed(dismissed bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Resolved(resolved bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Execute() (*InlineResponse200234, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewByNetworkExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewByNetwork Return a Summary of Alerts grouped by network and severity

Return a Summary of Alerts grouped by network and severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest
*/
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverviewByNetwork(ctx context.Context, organizationId string) AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	return AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200234
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverviewByNetworkExecute(r AlertsApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) (*InlineResponse200234, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200234
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetOrganizationAssuranceAlertsOverviewByNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/byNetwork"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.tsStart != nil {
		localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	}
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	if r.deviceTags != nil {
		localVarQueryParams.Add("deviceTags", parameterToString(*r.deviceTags, "csv"))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.dismissed != nil {
		localVarQueryParams.Add("dismissed", parameterToString(*r.dismissed, ""))
	}
	if r.resolved != nil {
		localVarQueryParams.Add("resolved", parameterToString(*r.resolved, ""))
	}
	if r.suppressAlertsForOfflineNodes != nil {
		localVarQueryParams.Add("suppressAlertsForOfflineNodes", parameterToString(*r.suppressAlertsForOfflineNodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	sortBy *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) PerPage(perPage int32) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) StartingAfter(startingAfter string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) EndingBefore(endingBefore string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) SortOrder(sortOrder string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts overview by network ids.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) NetworkId(networkId string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Severity(severity string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Types(types []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) TsStart(tsStart time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) TsEnd(tsEnd time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Category(category string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.category = &category
	return r
}

// Optional parameter to set column to sort by.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) SortBy(sortBy string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.sortBy = &sortBy
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Serials(serials []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) DeviceTypes(deviceTypes []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) DeviceTags(deviceTags []string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Active(active bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Dismissed(dismissed bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Resolved(resolved bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Execute() (*InlineResponse200235, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewByTypeExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewByType Return a Summary of Alerts grouped by type and severity

Return a Summary of Alerts grouped by type and severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest
*/
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverviewByType(ctx context.Context, organizationId string) AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	return AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200235
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverviewByTypeExecute(r AlertsApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) (*InlineResponse200235, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200235
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetOrganizationAssuranceAlertsOverviewByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/byType"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.tsStart != nil {
		localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	}
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	if r.deviceTags != nil {
		localVarQueryParams.Add("deviceTags", parameterToString(*r.deviceTags, "csv"))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.dismissed != nil {
		localVarQueryParams.Add("dismissed", parameterToString(*r.dismissed, ""))
	}
	if r.resolved != nil {
		localVarQueryParams.Add("resolved", parameterToString(*r.resolved, ""))
	}
	if r.suppressAlertsForOfflineNodes != nil {
		localVarQueryParams.Add("suppressAlertsForOfflineNodes", parameterToString(*r.suppressAlertsForOfflineNodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	segmentDuration *int32
	tsStart *time.Time
	networkId *string
	severity *string
	types *[]string
	tsEnd *time.Time
	category *string
	serials *[]string
	deviceTypes *[]string
}

// Amount of time in seconds for each segment in the returned dataset
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) SegmentDuration(segmentDuration int32) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.segmentDuration = &segmentDuration
	return r
}

// Parameter to define starting timestamp of historical totals
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) TsStart(tsStart time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter alerts overview by network ids.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) NetworkId(networkId string) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Severity(severity string) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Types(types []string) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by end timestamp defaults to the current time
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) TsEnd(tsEnd time.Time) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Category(category string) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.category = &category
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Serials(serials []string) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) DeviceTypes(deviceTypes []string) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.deviceTypes = &deviceTypes
	return r
}

func (r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Execute() (*InlineResponse200236, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewHistoricalExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewHistorical Returns historical health alert overviews

Returns historical health alert overviews

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest
*/
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverviewHistorical(ctx context.Context, organizationId string) AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	return AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200236
func (a *AlertsApiService) GetOrganizationAssuranceAlertsOverviewHistoricalExecute(r AlertsApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) (*InlineResponse200236, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200236
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.GetOrganizationAssuranceAlertsOverviewHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/historical"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.segmentDuration == nil {
		return localVarReturnValue, nil, reportError("segmentDuration is required and must be specified")
	}
	if r.tsStart == nil {
		return localVarReturnValue, nil, reportError("tsStart is required and must be specified")
	}

	localVarQueryParams.Add("segmentDuration", parameterToString(*r.segmentDuration, ""))
	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiRestoreOrganizationAssuranceAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	restoreOrganizationAssuranceAlerts *InlineObject231
}

func (r AlertsApiRestoreOrganizationAssuranceAlertsRequest) RestoreOrganizationAssuranceAlerts(restoreOrganizationAssuranceAlerts InlineObject231) AlertsApiRestoreOrganizationAssuranceAlertsRequest {
	r.restoreOrganizationAssuranceAlerts = &restoreOrganizationAssuranceAlerts
	return r
}

func (r AlertsApiRestoreOrganizationAssuranceAlertsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestoreOrganizationAssuranceAlertsExecute(r)
}

/*
RestoreOrganizationAssuranceAlerts Restore health alerts from dismissed

Restore health alerts from dismissed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsApiRestoreOrganizationAssuranceAlertsRequest
*/
func (a *AlertsApiService) RestoreOrganizationAssuranceAlerts(ctx context.Context, organizationId string) AlertsApiRestoreOrganizationAssuranceAlertsRequest {
	return AlertsApiRestoreOrganizationAssuranceAlertsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *AlertsApiService) RestoreOrganizationAssuranceAlertsExecute(r AlertsApiRestoreOrganizationAssuranceAlertsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.RestoreOrganizationAssuranceAlerts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreOrganizationAssuranceAlerts == nil {
		return nil, reportError("restoreOrganizationAssuranceAlerts is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreOrganizationAssuranceAlerts
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsApiUpdateNetworkAlertsSettingsRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
	updateNetworkAlertsSettings *InlineObject39
}

func (r AlertsApiUpdateNetworkAlertsSettingsRequest) UpdateNetworkAlertsSettings(updateNetworkAlertsSettings InlineObject39) AlertsApiUpdateNetworkAlertsSettingsRequest {
	r.updateNetworkAlertsSettings = &updateNetworkAlertsSettings
	return r
}

func (r AlertsApiUpdateNetworkAlertsSettingsRequest) Execute() (*InlineResponse20049, *http.Response, error) {
	return r.ApiService.UpdateNetworkAlertsSettingsExecute(r)
}

/*
UpdateNetworkAlertsSettings Update the alert configuration for this network

Update the alert configuration for this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsApiUpdateNetworkAlertsSettingsRequest
*/
func (a *AlertsApiService) UpdateNetworkAlertsSettings(ctx context.Context, networkId string) AlertsApiUpdateNetworkAlertsSettingsRequest {
	return AlertsApiUpdateNetworkAlertsSettingsRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return InlineResponse20049
func (a *AlertsApiService) UpdateNetworkAlertsSettingsExecute(r AlertsApiUpdateNetworkAlertsSettingsRequest) (*InlineResponse20049, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse20049
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.UpdateNetworkAlertsSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/alerts/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNetworkAlertsSettings
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiUpdateNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	networkId string
	id string
	updateNetworkSensorAlertsProfile *InlineObject116
}

func (r AlertsApiUpdateNetworkSensorAlertsProfileRequest) UpdateNetworkSensorAlertsProfile(updateNetworkSensorAlertsProfile InlineObject116) AlertsApiUpdateNetworkSensorAlertsProfileRequest {
	r.updateNetworkSensorAlertsProfile = &updateNetworkSensorAlertsProfile
	return r
}

func (r AlertsApiUpdateNetworkSensorAlertsProfileRequest) Execute() (*InlineResponse200116, *http.Response, error) {
	return r.ApiService.UpdateNetworkSensorAlertsProfileExecute(r)
}

/*
UpdateNetworkSensorAlertsProfile Updates a sensor alert profile for a network.

Updates a sensor alert profile for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @param id ID
 @return AlertsApiUpdateNetworkSensorAlertsProfileRequest
*/
func (a *AlertsApiService) UpdateNetworkSensorAlertsProfile(ctx context.Context, networkId string, id string) AlertsApiUpdateNetworkSensorAlertsProfileRequest {
	return AlertsApiUpdateNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
		id: id,
	}
}

// Execute executes the request
//  @return InlineResponse200116
func (a *AlertsApiService) UpdateNetworkSensorAlertsProfileExecute(r AlertsApiUpdateNetworkSensorAlertsProfileRequest) (*InlineResponse200116, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200116
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.UpdateNetworkSensorAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNetworkSensorAlertsProfile
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsApiUpdateOrganizationAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsApiService
	organizationId string
	alertConfigId string
	updateOrganizationAlertsProfile *InlineObject216
}

func (r AlertsApiUpdateOrganizationAlertsProfileRequest) UpdateOrganizationAlertsProfile(updateOrganizationAlertsProfile InlineObject216) AlertsApiUpdateOrganizationAlertsProfileRequest {
	r.updateOrganizationAlertsProfile = &updateOrganizationAlertsProfile
	return r
}

func (r AlertsApiUpdateOrganizationAlertsProfileRequest) Execute() (*InlineResponse200214, *http.Response, error) {
	return r.ApiService.UpdateOrganizationAlertsProfileExecute(r)
}

/*
UpdateOrganizationAlertsProfile Update an organization-wide alert config

Update an organization-wide alert config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param alertConfigId Alert config ID
 @return AlertsApiUpdateOrganizationAlertsProfileRequest
*/
func (a *AlertsApiService) UpdateOrganizationAlertsProfile(ctx context.Context, organizationId string, alertConfigId string) AlertsApiUpdateOrganizationAlertsProfileRequest {
	return AlertsApiUpdateOrganizationAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		alertConfigId: alertConfigId,
	}
}

// Execute executes the request
//  @return InlineResponse200214
func (a *AlertsApiService) UpdateOrganizationAlertsProfileExecute(r AlertsApiUpdateOrganizationAlertsProfileRequest) (*InlineResponse200214, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200214
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsApiService.UpdateOrganizationAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles/{alertConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertConfigId"+"}", url.PathEscape(parameterToString(r.alertConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationAlertsProfile
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
