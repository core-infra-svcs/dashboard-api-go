/*
Meraki Dashboard API

The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 04 June, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

API version: 1.59.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// OverviewApiService OverviewApi service
type OverviewApiService service

type OverviewApiGetDeviceCameraAnalyticsOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	serial string
	t0 *string
	t1 *string
	timespan *float32
	objectType *string
}

// The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
func (r OverviewApiGetDeviceCameraAnalyticsOverviewRequest) T0(t0 string) OverviewApiGetDeviceCameraAnalyticsOverviewRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 7 days after t0.
func (r OverviewApiGetDeviceCameraAnalyticsOverviewRequest) T1(t1 string) OverviewApiGetDeviceCameraAnalyticsOverviewRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour.
func (r OverviewApiGetDeviceCameraAnalyticsOverviewRequest) Timespan(timespan float32) OverviewApiGetDeviceCameraAnalyticsOverviewRequest {
	r.timespan = &timespan
	return r
}

// [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle].
func (r OverviewApiGetDeviceCameraAnalyticsOverviewRequest) ObjectType(objectType string) OverviewApiGetDeviceCameraAnalyticsOverviewRequest {
	r.objectType = &objectType
	return r
}

func (r OverviewApiGetDeviceCameraAnalyticsOverviewRequest) Execute() ([]InlineResponse20012, *http.Response, error) {
	return r.ApiService.GetDeviceCameraAnalyticsOverviewExecute(r)
}

/*
GetDeviceCameraAnalyticsOverview Returns an overview of aggregate analytics data for a timespan

Returns an overview of aggregate analytics data for a timespan

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serial Serial
 @return OverviewApiGetDeviceCameraAnalyticsOverviewRequest

Deprecated
*/
func (a *OverviewApiService) GetDeviceCameraAnalyticsOverview(ctx context.Context, serial string) OverviewApiGetDeviceCameraAnalyticsOverviewRequest {
	return OverviewApiGetDeviceCameraAnalyticsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		serial: serial,
	}
}

// Execute executes the request
//  @return []InlineResponse20012
// Deprecated
func (a *OverviewApiService) GetDeviceCameraAnalyticsOverviewExecute(r OverviewApiGetDeviceCameraAnalyticsOverviewRequest) ([]InlineResponse20012, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse20012
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetDeviceCameraAnalyticsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/devices/{serial}/camera/analytics/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"serial"+"}", url.PathEscape(parameterToString(r.serial, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.objectType != nil {
		localVarQueryParams.Add("objectType", parameterToString(*r.objectType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetNetworkClientsOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	networkId string
	t0 *string
	t1 *string
	timespan *float32
	resolution *int32
}

// The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
func (r OverviewApiGetNetworkClientsOverviewRequest) T0(t0 string) OverviewApiGetNetworkClientsOverviewRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
func (r OverviewApiGetNetworkClientsOverviewRequest) T1(t1 string) OverviewApiGetNetworkClientsOverviewRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
func (r OverviewApiGetNetworkClientsOverviewRequest) Timespan(timespan float32) OverviewApiGetNetworkClientsOverviewRequest {
	r.timespan = &timespan
	return r
}

// The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800.
func (r OverviewApiGetNetworkClientsOverviewRequest) Resolution(resolution int32) OverviewApiGetNetworkClientsOverviewRequest {
	r.resolution = &resolution
	return r
}

func (r OverviewApiGetNetworkClientsOverviewRequest) Execute() (*InlineResponse20087, *http.Response, error) {
	return r.ApiService.GetNetworkClientsOverviewExecute(r)
}

/*
GetNetworkClientsOverview Return overview statistics for network clients

Return overview statistics for network clients

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return OverviewApiGetNetworkClientsOverviewRequest
*/
func (a *OverviewApiService) GetNetworkClientsOverview(ctx context.Context, networkId string) OverviewApiGetNetworkClientsOverviewRequest {
	return OverviewApiGetNetworkClientsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return InlineResponse20087
func (a *OverviewApiService) GetNetworkClientsOverviewExecute(r OverviewApiGetNetworkClientsOverviewRequest) (*InlineResponse20087, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse20087
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetNetworkClientsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/clients/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.resolution != nil {
		localVarQueryParams.Add("resolution", parameterToString(*r.resolution, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	networkId string
}

func (r OverviewApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest) Execute() (*InlineResponse200116, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsCurrentOverviewByMetricExecute(r)
}

/*
GetNetworkSensorAlertsCurrentOverviewByMetric Return an overview of currently alerting sensors by metric

Return an overview of currently alerting sensors by metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return OverviewApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest
*/
func (a *OverviewApiService) GetNetworkSensorAlertsCurrentOverviewByMetric(ctx context.Context, networkId string) OverviewApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest {
	return OverviewApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return InlineResponse200116
func (a *OverviewApiService) GetNetworkSensorAlertsCurrentOverviewByMetricExecute(r OverviewApiGetNetworkSensorAlertsCurrentOverviewByMetricRequest) (*InlineResponse200116, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200116
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetNetworkSensorAlertsCurrentOverviewByMetric")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/current/overview/byMetric"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	networkId string
	t0 *string
	t1 *string
	timespan *float32
	interval *int32
}

// The beginning of the timespan for the data. The maximum lookback period is 731 days from today.
func (r OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest) T0(t0 string) OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 366 days after t0.
func (r OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest) T1(t1 string) OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 366 days. The default is 7 days. If interval is provided, the timespan will be autocalculated.
func (r OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest) Timespan(timespan float32) OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.timespan = &timespan
	return r
}

// The time interval in seconds for returned data. The valid intervals are: 900, 3600, 86400, 604800, 2592000. The default is 604800. Interval is calculated if time params are provided.
func (r OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest) Interval(interval int32) OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest {
	r.interval = &interval
	return r
}

func (r OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest) Execute() ([]InlineResponse200117, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsOverviewByMetricExecute(r)
}

/*
GetNetworkSensorAlertsOverviewByMetric Return an overview of alert occurrences over a timespan, by metric

Return an overview of alert occurrences over a timespan, by metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest
*/
func (a *OverviewApiService) GetNetworkSensorAlertsOverviewByMetric(ctx context.Context, networkId string) OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest {
	return OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []InlineResponse200117
func (a *OverviewApiService) GetNetworkSensorAlertsOverviewByMetricExecute(r OverviewApiGetNetworkSensorAlertsOverviewByMetricRequest) ([]InlineResponse200117, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200117
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetNetworkSensorAlertsOverviewByMetric")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/overview/byMetric"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationAdaptivePolicyOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
}

func (r OverviewApiGetOrganizationAdaptivePolicyOverviewRequest) Execute() (*InlineResponse200213, *http.Response, error) {
	return r.ApiService.GetOrganizationAdaptivePolicyOverviewExecute(r)
}

/*
GetOrganizationAdaptivePolicyOverview Returns adaptive policy aggregate statistics for an organization

Returns adaptive policy aggregate statistics for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationAdaptivePolicyOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationAdaptivePolicyOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationAdaptivePolicyOverviewRequest {
	return OverviewApiGetOrganizationAdaptivePolicyOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200213
func (a *OverviewApiService) GetOrganizationAdaptivePolicyOverviewExecute(r OverviewApiGetOrganizationAdaptivePolicyOverviewRequest) (*InlineResponse200213, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200213
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationAdaptivePolicyOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/adaptivePolicy/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationApiRequestsOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	t0 *string
	t1 *string
	timespan *float32
}

// The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
func (r OverviewApiGetOrganizationApiRequestsOverviewRequest) T0(t0 string) OverviewApiGetOrganizationApiRequestsOverviewRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
func (r OverviewApiGetOrganizationApiRequestsOverviewRequest) T1(t1 string) OverviewApiGetOrganizationApiRequestsOverviewRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days.
func (r OverviewApiGetOrganizationApiRequestsOverviewRequest) Timespan(timespan float32) OverviewApiGetOrganizationApiRequestsOverviewRequest {
	r.timespan = &timespan
	return r
}

func (r OverviewApiGetOrganizationApiRequestsOverviewRequest) Execute() (*InlineResponse200219, *http.Response, error) {
	return r.ApiService.GetOrganizationApiRequestsOverviewExecute(r)
}

/*
GetOrganizationApiRequestsOverview Return an aggregated overview of API requests data

Return an aggregated overview of API requests data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationApiRequestsOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationApiRequestsOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationApiRequestsOverviewRequest {
	return OverviewApiGetOrganizationApiRequestsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200219
func (a *OverviewApiService) GetOrganizationApiRequestsOverviewExecute(r OverviewApiGetOrganizationApiRequestsOverviewRequest) (*InlineResponse200219, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200219
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationApiRequestsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/apiRequests/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	t0 *string
	t1 *string
	timespan *float32
	interval *int32
	version *int32
	operationIds *[]string
	sourceIps *[]string
	adminIds *[]string
	userAgent *string
}

// The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) T0(t0 string) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) T1(t1 string) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. If interval is provided, the timespan will be autocalculated.
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) Timespan(timespan float32) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.timespan = &timespan
	return r
}

// The time interval in seconds for returned data. The valid intervals are: 120, 3600, 14400, 21600. The default is 21600. Interval is calculated if time params are provided.
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) Interval(interval int32) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.interval = &interval
	return r
}

// Filter by API version of the endpoint. Allowable values are: [0, 1]
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) Version(version int32) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.version = &version
	return r
}

// Filter by operation ID of the endpoint
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) OperationIds(operationIds []string) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.operationIds = &operationIds
	return r
}

// Filter by source IP that made the API request
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) SourceIps(sourceIps []string) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.sourceIps = &sourceIps
	return r
}

// Filter by admin ID of user that made the API request
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) AdminIds(adminIds []string) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.adminIds = &adminIds
	return r
}

// Filter by user agent string for API request. This will filter by a complete or partial match.
func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) UserAgent(userAgent string) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	r.userAgent = &userAgent
	return r
}

func (r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) Execute() ([]InlineResponse200220, *http.Response, error) {
	return r.ApiService.GetOrganizationApiRequestsOverviewResponseCodesByIntervalExecute(r)
}

/*
GetOrganizationApiRequestsOverviewResponseCodesByInterval Tracks organizations' API requests by response code across a given time period

Tracks organizations' API requests by response code across a given time period

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest
*/
func (a *OverviewApiService) GetOrganizationApiRequestsOverviewResponseCodesByInterval(ctx context.Context, organizationId string) OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest {
	return OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return []InlineResponse200220
func (a *OverviewApiService) GetOrganizationApiRequestsOverviewResponseCodesByIntervalExecute(r OverviewApiGetOrganizationApiRequestsOverviewResponseCodesByIntervalRequest) ([]InlineResponse200220, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []InlineResponse200220
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationApiRequestsOverviewResponseCodesByInterval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/apiRequests/overview/responseCodes/byInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.operationIds != nil {
		localVarQueryParams.Add("operationIds", parameterToString(*r.operationIds, "csv"))
	}
	if r.sourceIps != nil {
		localVarQueryParams.Add("sourceIps", parameterToString(*r.sourceIps, "csv"))
	}
	if r.adminIds != nil {
		localVarQueryParams.Add("adminIds", parameterToString(*r.adminIds, "csv"))
	}
	if r.userAgent != nil {
		localVarQueryParams.Add("userAgent", parameterToString(*r.userAgent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationApplianceUplinksStatusesOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
}

func (r OverviewApiGetOrganizationApplianceUplinksStatusesOverviewRequest) Execute() (*InlineResponse200231, *http.Response, error) {
	return r.ApiService.GetOrganizationApplianceUplinksStatusesOverviewExecute(r)
}

/*
GetOrganizationApplianceUplinksStatusesOverview Returns an overview of uplink statuses

Returns an overview of uplink statuses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationApplianceUplinksStatusesOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationApplianceUplinksStatusesOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationApplianceUplinksStatusesOverviewRequest {
	return OverviewApiGetOrganizationApplianceUplinksStatusesOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200231
func (a *OverviewApiService) GetOrganizationApplianceUplinksStatusesOverviewExecute(r OverviewApiGetOrganizationApplianceUplinksStatusesOverviewRequest) (*InlineResponse200231, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200231
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationApplianceUplinksStatusesOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/appliance/uplinks/statuses/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationAssuranceAlertsOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// Optional parameter to filter alerts overview by network ids.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) NetworkId(networkId string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Severity(severity string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Types(types []string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) TsStart(tsStart time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) TsEnd(tsEnd time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Category(category string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.category = &category
	return r
}

// Optional parameter to filter by primary device serial
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Serials(serials []string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) DeviceTypes(deviceTypes []string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) DeviceTags(deviceTags []string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Active(active bool) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Dismissed(dismissed bool) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Resolved(resolved bool) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) Execute() (*InlineResponse200239, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverview Return overview of active health alerts for an organization

Return overview of active health alerts for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationAssuranceAlertsOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationAssuranceAlertsOverviewRequest {
	return OverviewApiGetOrganizationAssuranceAlertsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200239
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverviewExecute(r OverviewApiGetOrganizationAssuranceAlertsOverviewRequest) (*InlineResponse200239, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200239
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationAssuranceAlertsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.tsStart != nil {
		localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	}
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	if r.deviceTags != nil {
		localVarQueryParams.Add("deviceTags", parameterToString(*r.deviceTags, "csv"))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.dismissed != nil {
		localVarQueryParams.Add("dismissed", parameterToString(*r.dismissed, ""))
	}
	if r.resolved != nil {
		localVarQueryParams.Add("resolved", parameterToString(*r.resolved, ""))
	}
	if r.suppressAlertsForOfflineNodes != nil {
		localVarQueryParams.Add("suppressAlertsForOfflineNodes", parameterToString(*r.suppressAlertsForOfflineNodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) PerPage(perPage int32) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) StartingAfter(startingAfter string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) EndingBefore(endingBefore string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) SortOrder(sortOrder string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts overview by network id.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) NetworkId(networkId string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Severity(severity string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Types(types []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) TsStart(tsStart time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) TsEnd(tsEnd time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Category(category string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.category = &category
	return r
}

// Optional parameter to filter by primary device serial
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Serials(serials []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) DeviceTypes(deviceTypes []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) DeviceTags(deviceTags []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Active(active bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Dismissed(dismissed bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Resolved(resolved bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Execute() (*InlineResponse200240, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewByNetworkExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewByNetwork Return a Summary of Alerts grouped by network and severity

Return a Summary of Alerts grouped by network and severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest
*/
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverviewByNetwork(ctx context.Context, organizationId string) OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	return OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200240
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverviewByNetworkExecute(r OverviewApiGetOrganizationAssuranceAlertsOverviewByNetworkRequest) (*InlineResponse200240, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200240
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationAssuranceAlertsOverviewByNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/byNetwork"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.tsStart != nil {
		localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	}
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	if r.deviceTags != nil {
		localVarQueryParams.Add("deviceTags", parameterToString(*r.deviceTags, "csv"))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.dismissed != nil {
		localVarQueryParams.Add("dismissed", parameterToString(*r.dismissed, ""))
	}
	if r.resolved != nil {
		localVarQueryParams.Add("resolved", parameterToString(*r.resolved, ""))
	}
	if r.suppressAlertsForOfflineNodes != nil {
		localVarQueryParams.Add("suppressAlertsForOfflineNodes", parameterToString(*r.suppressAlertsForOfflineNodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	sortBy *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) PerPage(perPage int32) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) StartingAfter(startingAfter string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) EndingBefore(endingBefore string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) SortOrder(sortOrder string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts overview by network ids.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) NetworkId(networkId string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Severity(severity string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Types(types []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) TsStart(tsStart time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) TsEnd(tsEnd time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Category(category string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.category = &category
	return r
}

// Optional parameter to set column to sort by.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) SortBy(sortBy string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.sortBy = &sortBy
	return r
}

// Optional parameter to filter by primary device serial
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Serials(serials []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) DeviceTypes(deviceTypes []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) DeviceTags(deviceTags []string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Active(active bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Dismissed(dismissed bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Resolved(resolved bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) Execute() (*InlineResponse200241, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewByTypeExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewByType Return a Summary of Alerts grouped by type and severity

Return a Summary of Alerts grouped by type and severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest
*/
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverviewByType(ctx context.Context, organizationId string) OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	return OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200241
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverviewByTypeExecute(r OverviewApiGetOrganizationAssuranceAlertsOverviewByTypeRequest) (*InlineResponse200241, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200241
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationAssuranceAlertsOverviewByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/byType"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	if r.tsStart != nil {
		localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	}
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	if r.deviceTags != nil {
		localVarQueryParams.Add("deviceTags", parameterToString(*r.deviceTags, "csv"))
	}
	if r.active != nil {
		localVarQueryParams.Add("active", parameterToString(*r.active, ""))
	}
	if r.dismissed != nil {
		localVarQueryParams.Add("dismissed", parameterToString(*r.dismissed, ""))
	}
	if r.resolved != nil {
		localVarQueryParams.Add("resolved", parameterToString(*r.resolved, ""))
	}
	if r.suppressAlertsForOfflineNodes != nil {
		localVarQueryParams.Add("suppressAlertsForOfflineNodes", parameterToString(*r.suppressAlertsForOfflineNodes, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	segmentDuration *int32
	tsStart *time.Time
	networkId *string
	severity *string
	types *[]string
	tsEnd *time.Time
	category *string
	serials *[]string
	deviceTypes *[]string
}

// Amount of time in seconds for each segment in the returned dataset
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) SegmentDuration(segmentDuration int32) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.segmentDuration = &segmentDuration
	return r
}

// Parameter to define starting timestamp of historical totals
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) TsStart(tsStart time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter alerts overview by network ids.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) NetworkId(networkId string) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Severity(severity string) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Types(types []string) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by end timestamp defaults to the current time
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) TsEnd(tsEnd time.Time) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Category(category string) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.category = &category
	return r
}

// Optional parameter to filter by primary device serial
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Serials(serials []string) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) DeviceTypes(deviceTypes []string) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.deviceTypes = &deviceTypes
	return r
}

func (r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Execute() (*InlineResponse200242, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewHistoricalExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewHistorical Returns historical health alert overviews

Returns historical health alert overviews

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest
*/
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverviewHistorical(ctx context.Context, organizationId string) OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	return OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200242
func (a *OverviewApiService) GetOrganizationAssuranceAlertsOverviewHistoricalExecute(r OverviewApiGetOrganizationAssuranceAlertsOverviewHistoricalRequest) (*InlineResponse200242, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200242
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationAssuranceAlertsOverviewHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/historical"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.segmentDuration == nil {
		return localVarReturnValue, nil, reportError("segmentDuration is required and must be specified")
	}
	if r.tsStart == nil {
		return localVarReturnValue, nil, reportError("tsStart is required and must be specified")
	}

	localVarQueryParams.Add("segmentDuration", parameterToString(*r.segmentDuration, ""))
	if r.networkId != nil {
		localVarQueryParams.Add("networkId", parameterToString(*r.networkId, ""))
	}
	if r.severity != nil {
		localVarQueryParams.Add("severity", parameterToString(*r.severity, ""))
	}
	if r.types != nil {
		localVarQueryParams.Add("types", parameterToString(*r.types, "csv"))
	}
	localVarQueryParams.Add("tsStart", parameterToString(*r.tsStart, ""))
	if r.tsEnd != nil {
		localVarQueryParams.Add("tsEnd", parameterToString(*r.tsEnd, ""))
	}
	if r.category != nil {
		localVarQueryParams.Add("category", parameterToString(*r.category, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.deviceTypes != nil {
		localVarQueryParams.Add("deviceTypes", parameterToString(*r.deviceTypes, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationClientsOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	t0 *string
	t1 *string
	timespan *float32
}

// The beginning of the timespan for the data.
func (r OverviewApiGetOrganizationClientsOverviewRequest) T0(t0 string) OverviewApiGetOrganizationClientsOverviewRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
func (r OverviewApiGetOrganizationClientsOverviewRequest) T1(t1 string) OverviewApiGetOrganizationClientsOverviewRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
func (r OverviewApiGetOrganizationClientsOverviewRequest) Timespan(timespan float32) OverviewApiGetOrganizationClientsOverviewRequest {
	r.timespan = &timespan
	return r
}

func (r OverviewApiGetOrganizationClientsOverviewRequest) Execute() (*InlineResponse200262, *http.Response, error) {
	return r.ApiService.GetOrganizationClientsOverviewExecute(r)
}

/*
GetOrganizationClientsOverview Return summary information around client data usage (in kb) across the given organization.

Return summary information around client data usage (in kb) across the given organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationClientsOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationClientsOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationClientsOverviewRequest {
	return OverviewApiGetOrganizationClientsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200262
func (a *OverviewApiService) GetOrganizationClientsOverviewExecute(r OverviewApiGetOrganizationClientsOverviewRequest) (*InlineResponse200262, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200262
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationClientsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/clients/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationDevicesOverviewByModelRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	models *[]string
	networkIds *[]string
	productTypes *[]string
}

// Optional parameter to filter devices by one or more models. All returned devices will have a model that is an exact match.
func (r OverviewApiGetOrganizationDevicesOverviewByModelRequest) Models(models []string) OverviewApiGetOrganizationDevicesOverviewByModelRequest {
	r.models = &models
	return r
}

// Optional parameter to filter devices by networkId.
func (r OverviewApiGetOrganizationDevicesOverviewByModelRequest) NetworkIds(networkIds []string) OverviewApiGetOrganizationDevicesOverviewByModelRequest {
	r.networkIds = &networkIds
	return r
}

// Optional parameter to filter device by device product types. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationDevicesOverviewByModelRequest) ProductTypes(productTypes []string) OverviewApiGetOrganizationDevicesOverviewByModelRequest {
	r.productTypes = &productTypes
	return r
}

func (r OverviewApiGetOrganizationDevicesOverviewByModelRequest) Execute() (*InlineResponse200272, *http.Response, error) {
	return r.ApiService.GetOrganizationDevicesOverviewByModelExecute(r)
}

/*
GetOrganizationDevicesOverviewByModel Lists the count for each device model

Lists the count for each device model

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationDevicesOverviewByModelRequest
*/
func (a *OverviewApiService) GetOrganizationDevicesOverviewByModel(ctx context.Context, organizationId string) OverviewApiGetOrganizationDevicesOverviewByModelRequest {
	return OverviewApiGetOrganizationDevicesOverviewByModelRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200272
func (a *OverviewApiService) GetOrganizationDevicesOverviewByModelExecute(r OverviewApiGetOrganizationDevicesOverviewByModelRequest) (*InlineResponse200272, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200272
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationDevicesOverviewByModel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/overview/byModel"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.models != nil {
		localVarQueryParams.Add("models", parameterToString(*r.models, "csv"))
	}
	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.productTypes != nil {
		localVarQueryParams.Add("productTypes", parameterToString(*r.productTypes, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationDevicesStatusesOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	productTypes *[]string
	networkIds *[]string
}

// An optional parameter to filter device statuses by product type. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor, wirelessController, campusGateway, and secureConnect.
func (r OverviewApiGetOrganizationDevicesStatusesOverviewRequest) ProductTypes(productTypes []string) OverviewApiGetOrganizationDevicesStatusesOverviewRequest {
	r.productTypes = &productTypes
	return r
}

// An optional parameter to filter device statuses by network.
func (r OverviewApiGetOrganizationDevicesStatusesOverviewRequest) NetworkIds(networkIds []string) OverviewApiGetOrganizationDevicesStatusesOverviewRequest {
	r.networkIds = &networkIds
	return r
}

func (r OverviewApiGetOrganizationDevicesStatusesOverviewRequest) Execute() (*InlineResponse200280, *http.Response, error) {
	return r.ApiService.GetOrganizationDevicesStatusesOverviewExecute(r)
}

/*
GetOrganizationDevicesStatusesOverview Return an overview of current device statuses

Return an overview of current device statuses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationDevicesStatusesOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationDevicesStatusesOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationDevicesStatusesOverviewRequest {
	return OverviewApiGetOrganizationDevicesStatusesOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200280
func (a *OverviewApiService) GetOrganizationDevicesStatusesOverviewExecute(r OverviewApiGetOrganizationDevicesStatusesOverviewRequest) (*InlineResponse200280, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200280
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationDevicesStatusesOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/statuses/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.productTypes != nil {
		localVarQueryParams.Add("productTypes", parameterToString(*r.productTypes, "csv"))
	}
	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationLicensesOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
}

func (r OverviewApiGetOrganizationLicensesOverviewRequest) Execute() (*InlineResponse200302, *http.Response, error) {
	return r.ApiService.GetOrganizationLicensesOverviewExecute(r)
}

/*
GetOrganizationLicensesOverview Return an overview of the license state for an organization

Return an overview of the license state for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationLicensesOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationLicensesOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationLicensesOverviewRequest {
	return OverviewApiGetOrganizationLicensesOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200302
func (a *OverviewApiService) GetOrganizationLicensesOverviewExecute(r OverviewApiGetOrganizationLicensesOverviewRequest) (*InlineResponse200302, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200302
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationLicensesOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/licenses/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	t0 *string
	timespan *float32
	perPage *int32
	startingAfter *string
	endingBefore *string
	configurationUpdatedAfter *time.Time
	mac *string
	macs *[]string
	name *string
	networkIds *[]string
	portProfileIds *[]string
	serial *string
	serials *[]string
}

// The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) T0(t0 string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.t0 = &t0
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) Timespan(timespan float32) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.timespan = &timespan
	return r
}

// The number of entries per page returned. Acceptable range is 3 - 20. Default is 20.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) PerPage(perPage int32) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) StartingAfter(startingAfter string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) EndingBefore(endingBefore string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.endingBefore = &endingBefore
	return r
}

// Optional parameter to filter items to switches where the configuration has been updated after the given timestamp.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) ConfigurationUpdatedAfter(configurationUpdatedAfter time.Time) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.configurationUpdatedAfter = &configurationUpdatedAfter
	return r
}

// Optional parameter to filter items to switches with MAC addresses that contain the search term or are an exact match.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) Mac(mac string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.mac = &mac
	return r
}

// Optional parameter to filter items to switches that have one of the provided MAC addresses.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) Macs(macs []string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.macs = &macs
	return r
}

// Optional parameter to filter items to switches with names that contain the search term or are an exact match.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) Name(name string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.name = &name
	return r
}

// Optional parameter to filter items to switches in one of the provided networks.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) NetworkIds(networkIds []string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.networkIds = &networkIds
	return r
}

// Optional parameter to filter items to switches that contain switchports belonging to one of the specified port profiles.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) PortProfileIds(portProfileIds []string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.portProfileIds = &portProfileIds
	return r
}

// Optional parameter to filter items to switches with serial number that contains the search term or are an exact match.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) Serial(serial string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.serial = &serial
	return r
}

// Optional parameter to filter items to switches that have one of the provided serials.
func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) Serials(serials []string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	r.serials = &serials
	return r
}

func (r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) Execute() (*InlineResponse200336, *http.Response, error) {
	return r.ApiService.GetOrganizationSwitchPortsClientsOverviewByDeviceExecute(r)
}

/*
GetOrganizationSwitchPortsClientsOverviewByDevice List the number of clients for all switchports with at least one online client in an organization.

List the number of clients for all switchports with at least one online client in an organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest
*/
func (a *OverviewApiService) GetOrganizationSwitchPortsClientsOverviewByDevice(ctx context.Context, organizationId string) OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest {
	return OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200336
func (a *OverviewApiService) GetOrganizationSwitchPortsClientsOverviewByDeviceExecute(r OverviewApiGetOrganizationSwitchPortsClientsOverviewByDeviceRequest) (*InlineResponse200336, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200336
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationSwitchPortsClientsOverviewByDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/switch/ports/clients/overview/byDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.configurationUpdatedAfter != nil {
		localVarQueryParams.Add("configurationUpdatedAfter", parameterToString(*r.configurationUpdatedAfter, ""))
	}
	if r.mac != nil {
		localVarQueryParams.Add("mac", parameterToString(*r.mac, ""))
	}
	if r.macs != nil {
		localVarQueryParams.Add("macs", parameterToString(*r.macs, "csv"))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.portProfileIds != nil {
		localVarQueryParams.Add("portProfileIds", parameterToString(*r.portProfileIds, "csv"))
	}
	if r.serial != nil {
		localVarQueryParams.Add("serial", parameterToString(*r.serial, ""))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationSwitchPortsOverviewRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	t0 *string
	t1 *string
	timespan *float32
}

// The beginning of the timespan for the data.
func (r OverviewApiGetOrganizationSwitchPortsOverviewRequest) T0(t0 string) OverviewApiGetOrganizationSwitchPortsOverviewRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 186 days after t0.
func (r OverviewApiGetOrganizationSwitchPortsOverviewRequest) T1(t1 string) OverviewApiGetOrganizationSwitchPortsOverviewRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be greater than or equal to 12 hours and be less than or equal to 186 days. The default is 1 day.
func (r OverviewApiGetOrganizationSwitchPortsOverviewRequest) Timespan(timespan float32) OverviewApiGetOrganizationSwitchPortsOverviewRequest {
	r.timespan = &timespan
	return r
}

func (r OverviewApiGetOrganizationSwitchPortsOverviewRequest) Execute() (*InlineResponse200337, *http.Response, error) {
	return r.ApiService.GetOrganizationSwitchPortsOverviewExecute(r)
}

/*
GetOrganizationSwitchPortsOverview Returns the counts of all active ports for the requested timespan, grouped by speed

Returns the counts of all active ports for the requested timespan, grouped by speed. An active port is a port that at any point during the timeframe is observed to be connected to a responsive device and isn't configured to be disabled. For a port that is observed at multiple speeds during the timeframe, it will be counted at the highest speed observed. The number of inactive ports, and the total number of ports are also provided. Only ports on switches online during the timeframe will be represented and a port is only guaranteed to be present if its switch was online for at least 6 hours of the timeframe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationSwitchPortsOverviewRequest
*/
func (a *OverviewApiService) GetOrganizationSwitchPortsOverview(ctx context.Context, organizationId string) OverviewApiGetOrganizationSwitchPortsOverviewRequest {
	return OverviewApiGetOrganizationSwitchPortsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200337
func (a *OverviewApiService) GetOrganizationSwitchPortsOverviewExecute(r OverviewApiGetOrganizationSwitchPortsOverviewRequest) (*InlineResponse200337, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200337
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationSwitchPortsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/switch/ports/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	networkIds *[]string
	serials *[]string
	campusGatewayClusterIds *[]string
	perPage *int32
	startingAfter *string
	endingBefore *string
}

// Optional parameter to filter access points client counts by network ID. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) NetworkIds(networkIds []string) OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest {
	r.networkIds = &networkIds
	return r
}

// Optional parameter to filter access points client counts by its serial numbers. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) Serials(serials []string) OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter access points client counts by MCG cluster IDs. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) CampusGatewayClusterIds(campusGatewayClusterIds []string) OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest {
	r.campusGatewayClusterIds = &campusGatewayClusterIds
	return r
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) PerPage(perPage int32) OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) StartingAfter(startingAfter string) OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) EndingBefore(endingBefore string) OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest {
	r.endingBefore = &endingBefore
	return r
}

func (r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) Execute() (*InlineResponse200347, *http.Response, error) {
	return r.ApiService.GetOrganizationWirelessClientsOverviewByDeviceExecute(r)
}

/*
GetOrganizationWirelessClientsOverviewByDevice List access point client count at the moment in an organization

List access point client count at the moment in an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest
*/
func (a *OverviewApiService) GetOrganizationWirelessClientsOverviewByDevice(ctx context.Context, organizationId string) OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest {
	return OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200347
func (a *OverviewApiService) GetOrganizationWirelessClientsOverviewByDeviceExecute(r OverviewApiGetOrganizationWirelessClientsOverviewByDeviceRequest) (*InlineResponse200347, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200347
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationWirelessClientsOverviewByDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wireless/clients/overview/byDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.campusGatewayClusterIds != nil {
		localVarQueryParams.Add("campusGatewayClusterIds", parameterToString(*r.campusGatewayClusterIds, "csv"))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	networkIds *[]string
	serials *[]string
	t0 *string
	t1 *string
	timespan *float32
	perPage *int32
	startingAfter *string
	endingBefore *string
	resolution *int32
}

// Optional parameter to filter wireless LAN controllers by network ID. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) NetworkIds(networkIds []string) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.networkIds = &networkIds
	return r
}

// Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) Serials(serials []string) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.serials = &serials
	return r
}

// The beginning of the timespan for the data. The maximum lookback period is 31 days from today.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) T0(t0 string) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) T1(t1 string) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) Timespan(timespan float32) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.timespan = &timespan
	return r
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) PerPage(perPage int32) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) StartingAfter(startingAfter string) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) EndingBefore(endingBefore string) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.endingBefore = &endingBefore
	return r
}

// The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400.
func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) Resolution(resolution int32) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	r.resolution = &resolution
	return r
}

func (r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) Execute() (*InlineResponse200369, *http.Response, error) {
	return r.ApiService.GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalExecute(r)
}

/*
GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval List wireless client counts of wireless LAN controllers over time in an organization

List wireless client counts of wireless LAN controllers over time in an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest
*/
func (a *OverviewApiService) GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval(ctx context.Context, organizationId string) OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest {
	return OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200369
func (a *OverviewApiService) GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalExecute(r OverviewApiGetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByIntervalRequest) (*InlineResponse200369, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200369
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationWirelessControllerClientsOverviewHistoryByDeviceByInterval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wirelessController/clients/overview/history/byDevice/byInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.resolution != nil {
		localVarQueryParams.Add("resolution", parameterToString(*r.resolution, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	serials *[]string
	names *[]string
	t0 *string
	t1 *string
	timespan *float32
	perPage *int32
	startingAfter *string
	endingBefore *string
}

// Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) Serials(serials []string) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter wireless LAN controller by its interface name. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) Names(names []string) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.names = &names
	return r
}

// The beginning of the timespan for the data. The maximum lookback period is 1 day from today.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) T0(t0 string) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 1 day after t0.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) T1(t1 string) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 1 day. The default is 1 hour.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) Timespan(timespan float32) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.timespan = &timespan
	return r
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) PerPage(perPage int32) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) StartingAfter(startingAfter string) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) EndingBefore(endingBefore string) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	r.endingBefore = &endingBefore
	return r
}

func (r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) Execute() (*InlineResponse200377, *http.Response, error) {
	return r.ApiService.GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceExecute(r)
}

/*
GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice Retrieve the packet counters for the interfaces of a Wireless LAN controller

Retrieve the packet counters for the interfaces of a Wireless LAN controller

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest
*/
func (a *OverviewApiService) GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice(ctx context.Context, organizationId string) OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest {
	return OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200377
func (a *OverviewApiService) GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceExecute(r OverviewApiGetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDeviceRequest) (*InlineResponse200377, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200377
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationWirelessControllerDevicesInterfacesPacketsOverviewByDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wirelessController/devices/interfaces/packets/overview/byDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.names != nil {
		localVarQueryParams.Add("names", parameterToString(*r.names, "csv"))
	}
	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest struct {
	ctx context.Context
	ApiService *OverviewApiService
	organizationId string
	networkIds *[]string
	serials *[]string
	perPage *int32
	startingAfter *string
	endingBefore *string
}

// Optional parameter to filter wireless LAN controllers by network ID. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest) NetworkIds(networkIds []string) OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest {
	r.networkIds = &networkIds
	return r
}

// Optional parameter to filter wireless LAN controller by its cloud ID. This filter uses multiple exact matches.
func (r OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest) Serials(serials []string) OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest {
	r.serials = &serials
	return r
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest) PerPage(perPage int32) OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest) StartingAfter(startingAfter string) OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest) EndingBefore(endingBefore string) OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest {
	r.endingBefore = &endingBefore
	return r
}

func (r OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest) Execute() (*InlineResponse200382, *http.Response, error) {
	return r.ApiService.GetOrganizationWirelessControllerOverviewByDeviceExecute(r)
}

/*
GetOrganizationWirelessControllerOverviewByDevice List the overview information of wireless LAN controllers in an organization and it is updated every minute.

List the overview information of wireless LAN controllers in an organization and it is updated every minute.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest
*/
func (a *OverviewApiService) GetOrganizationWirelessControllerOverviewByDevice(ctx context.Context, organizationId string) OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest {
	return OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200382
func (a *OverviewApiService) GetOrganizationWirelessControllerOverviewByDeviceExecute(r OverviewApiGetOrganizationWirelessControllerOverviewByDeviceRequest) (*InlineResponse200382, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200382
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OverviewApiService.GetOrganizationWirelessControllerOverviewByDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/wirelessController/overview/byDevice"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
