/*
Meraki Dashboard API

The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 01 October, 2025 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

API version: 1.63.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CapturesApiService CapturesApi service
type CapturesApiService service

type CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest struct {
	ctx context.Context
	ApiService *CapturesApiService
	organizationId string
	bulkOrganizationDevicesPacketCaptureCapturesCreate *InlineObject259
}

func (r CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest) BulkOrganizationDevicesPacketCaptureCapturesCreate(bulkOrganizationDevicesPacketCaptureCapturesCreate InlineObject259) CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest {
	r.bulkOrganizationDevicesPacketCaptureCapturesCreate = &bulkOrganizationDevicesPacketCaptureCapturesCreate
	return r
}

func (r CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest) Execute() (*InlineResponse20121, *http.Response, error) {
	return r.ApiService.BulkOrganizationDevicesPacketCaptureCapturesCreateExecute(r)
}

/*
BulkOrganizationDevicesPacketCaptureCapturesCreate Perform a packet capture on multiple devices and store in Meraki Cloud.

Perform a packet capture on multiple devices and store in Meraki Cloud.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest
*/
func (a *CapturesApiService) BulkOrganizationDevicesPacketCaptureCapturesCreate(ctx context.Context, organizationId string) CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest {
	return CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse20121
func (a *CapturesApiService) BulkOrganizationDevicesPacketCaptureCapturesCreateExecute(r CapturesApiBulkOrganizationDevicesPacketCaptureCapturesCreateRequest) (*InlineResponse20121, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse20121
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapturesApiService.BulkOrganizationDevicesPacketCaptureCapturesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/bulkCreate"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOrganizationDevicesPacketCaptureCapturesCreate == nil {
		return localVarReturnValue, nil, reportError("bulkOrganizationDevicesPacketCaptureCapturesCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOrganizationDevicesPacketCaptureCapturesCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest struct {
	ctx context.Context
	ApiService *CapturesApiService
	organizationId string
	bulkOrganizationDevicesPacketCaptureCapturesDelete *InlineObject260
}

func (r CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest) BulkOrganizationDevicesPacketCaptureCapturesDelete(bulkOrganizationDevicesPacketCaptureCapturesDelete InlineObject260) CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest {
	r.bulkOrganizationDevicesPacketCaptureCapturesDelete = &bulkOrganizationDevicesPacketCaptureCapturesDelete
	return r
}

func (r CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.BulkOrganizationDevicesPacketCaptureCapturesDeleteExecute(r)
}

/*
BulkOrganizationDevicesPacketCaptureCapturesDelete BulkDelete packet captures from cloud

BulkDelete packet captures from cloud

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest
*/
func (a *CapturesApiService) BulkOrganizationDevicesPacketCaptureCapturesDelete(ctx context.Context, organizationId string) CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest {
	return CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *CapturesApiService) BulkOrganizationDevicesPacketCaptureCapturesDeleteExecute(r CapturesApiBulkOrganizationDevicesPacketCaptureCapturesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapturesApiService.BulkOrganizationDevicesPacketCaptureCapturesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/bulkDelete"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bulkOrganizationDevicesPacketCaptureCapturesDelete == nil {
		return nil, reportError("bulkOrganizationDevicesPacketCaptureCapturesDelete is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkOrganizationDevicesPacketCaptureCapturesDelete
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest struct {
	ctx context.Context
	ApiService *CapturesApiService
	organizationId string
	createOrganizationDevicesPacketCaptureCapture *InlineObject258
}

func (r CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest) CreateOrganizationDevicesPacketCaptureCapture(createOrganizationDevicesPacketCaptureCapture InlineObject258) CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest {
	r.createOrganizationDevicesPacketCaptureCapture = &createOrganizationDevicesPacketCaptureCapture
	return r
}

func (r CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest) Execute() (*InlineResponse200278Items, *http.Response, error) {
	return r.ApiService.CreateOrganizationDevicesPacketCaptureCaptureExecute(r)
}

/*
CreateOrganizationDevicesPacketCaptureCapture Perform a packet capture on a device and store in Meraki Cloud

Perform a packet capture on a device and store in Meraki Cloud. Only a single switch may be chosen per request, while multiple access points are allowed at once.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest
*/
func (a *CapturesApiService) CreateOrganizationDevicesPacketCaptureCapture(ctx context.Context, organizationId string) CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest {
	return CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200278Items
func (a *CapturesApiService) CreateOrganizationDevicesPacketCaptureCaptureExecute(r CapturesApiCreateOrganizationDevicesPacketCaptureCaptureRequest) (*InlineResponse200278Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200278Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapturesApiService.CreateOrganizationDevicesPacketCaptureCapture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationDevicesPacketCaptureCapture == nil {
		return localVarReturnValue, nil, reportError("createOrganizationDevicesPacketCaptureCapture is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationDevicesPacketCaptureCapture
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapturesApiDeleteOrganizationDevicesPacketCaptureCaptureRequest struct {
	ctx context.Context
	ApiService *CapturesApiService
	organizationId string
	captureId string
}

func (r CapturesApiDeleteOrganizationDevicesPacketCaptureCaptureRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOrganizationDevicesPacketCaptureCaptureExecute(r)
}

/*
DeleteOrganizationDevicesPacketCaptureCapture Delete a single packet capture from cloud using captureId

Delete a single packet capture from cloud using captureId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param captureId Capture ID
 @return CapturesApiDeleteOrganizationDevicesPacketCaptureCaptureRequest
*/
func (a *CapturesApiService) DeleteOrganizationDevicesPacketCaptureCapture(ctx context.Context, organizationId string, captureId string) CapturesApiDeleteOrganizationDevicesPacketCaptureCaptureRequest {
	return CapturesApiDeleteOrganizationDevicesPacketCaptureCaptureRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		captureId: captureId,
	}
}

// Execute executes the request
func (a *CapturesApiService) DeleteOrganizationDevicesPacketCaptureCaptureExecute(r CapturesApiDeleteOrganizationDevicesPacketCaptureCaptureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapturesApiService.DeleteOrganizationDevicesPacketCaptureCapture")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/{captureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"captureId"+"}", url.PathEscape(parameterToString(r.captureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CapturesApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest struct {
	ctx context.Context
	ApiService *CapturesApiService
	organizationId string
	captureId string
}

func (r CapturesApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest) Execute() (*InlineResponse200279, *http.Response, error) {
	return r.ApiService.GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlExecute(r)
}

/*
GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrl Get presigned download URL for given packet capture id

Get presigned download URL for given packet capture id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param captureId Capture ID
 @return CapturesApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest
*/
func (a *CapturesApiService) GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrl(ctx context.Context, organizationId string, captureId string) CapturesApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest {
	return CapturesApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		captureId: captureId,
	}
}

// Execute executes the request
//  @return InlineResponse200279
func (a *CapturesApiService) GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlExecute(r CapturesApiGenerateOrganizationDevicesPacketCaptureCaptureDownloadUrlRequest) (*InlineResponse200279, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200279
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapturesApiService.GenerateOrganizationDevicesPacketCaptureCaptureDownloadUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/{captureId}/downloadUrl/generate"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"captureId"+"}", url.PathEscape(parameterToString(r.captureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest struct {
	ctx context.Context
	ApiService *CapturesApiService
	organizationId string
	captureIds *[]string
	networkIds *[]string
	serials *[]string
	process *[]string
	captureStatus *[]string
	name *[]string
	clientMac *[]string
	notes *string
	deviceName *string
	adminName *string
	t0 *string
	t1 *string
	timespan *float32
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
}

// Return the packet captures of the specified capture ids
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) CaptureIds(captureIds []string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.captureIds = &captureIds
	return r
}

// Return the packet captures of the specified network(s)
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) NetworkIds(networkIds []string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.networkIds = &networkIds
	return r
}

// Return the packet captures of the specified device(s)
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) Serials(serials []string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.serials = &serials
	return r
}

// Return the packet captures of the specified process
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) Process(process []string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.process = &process
	return r
}

// Return the packet captures of the specified capture status
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) CaptureStatus(captureStatus []string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.captureStatus = &captureStatus
	return r
}

// Return the packet captures matching the specified name
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) Name(name []string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.name = &name
	return r
}

// Return the packet captures matching the specified client macs
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) ClientMac(clientMac []string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.clientMac = &clientMac
	return r
}

// Return the packet captures matching the specified notes
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) Notes(notes string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.notes = &notes
	return r
}

// Return the packet captures matching the specified device name
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) DeviceName(deviceName string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.deviceName = &deviceName
	return r
}

// Return the packet captures matching the admin name
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) AdminName(adminName string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.adminName = &adminName
	return r
}

// The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) T0(t0 string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 365 days after t0.
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) T1(t1 string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days.
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) Timespan(timespan float32) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.timespan = &timespan
	return r
}

// The number of entries per page returned. Acceptable range is 3 - 100. Default is 10.
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) PerPage(perPage int32) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) StartingAfter(startingAfter string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) EndingBefore(endingBefore string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;descending&#39;.
func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) SortOrder(sortOrder string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) Execute() (*InlineResponse200278, *http.Response, error) {
	return r.ApiService.GetOrganizationDevicesPacketCaptureCapturesExecute(r)
}

/*
GetOrganizationDevicesPacketCaptureCaptures List Packet Captures

List Packet Captures. The current license level allows storage of up to 10 capture files in the cloud. When this limit is reached and a new capture is taken, the oldest capture will be automatically deleted to ensure sufficient space. Additional storage for switches will be available with an advantage license at a future date. These future capabilities will be consistent with what is available today via advantage licensing for access points.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest
*/
func (a *CapturesApiService) GetOrganizationDevicesPacketCaptureCaptures(ctx context.Context, organizationId string) CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest {
	return CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return InlineResponse200278
func (a *CapturesApiService) GetOrganizationDevicesPacketCaptureCapturesExecute(r CapturesApiGetOrganizationDevicesPacketCaptureCapturesRequest) (*InlineResponse200278, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200278
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapturesApiService.GetOrganizationDevicesPacketCaptureCaptures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.captureIds != nil {
		localVarQueryParams.Add("captureIds", parameterToString(*r.captureIds, "csv"))
	}
	if r.networkIds != nil {
		localVarQueryParams.Add("networkIds", parameterToString(*r.networkIds, "csv"))
	}
	if r.serials != nil {
		localVarQueryParams.Add("serials", parameterToString(*r.serials, "csv"))
	}
	if r.process != nil {
		localVarQueryParams.Add("process", parameterToString(*r.process, "csv"))
	}
	if r.captureStatus != nil {
		localVarQueryParams.Add("captureStatus", parameterToString(*r.captureStatus, "csv"))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, "csv"))
	}
	if r.clientMac != nil {
		localVarQueryParams.Add("clientMac", parameterToString(*r.clientMac, "csv"))
	}
	if r.notes != nil {
		localVarQueryParams.Add("notes", parameterToString(*r.notes, ""))
	}
	if r.deviceName != nil {
		localVarQueryParams.Add("deviceName", parameterToString(*r.deviceName, ""))
	}
	if r.adminName != nil {
		localVarQueryParams.Add("adminName", parameterToString(*r.adminName, ""))
	}
	if r.t0 != nil {
		localVarQueryParams.Add("t0", parameterToString(*r.t0, ""))
	}
	if r.t1 != nil {
		localVarQueryParams.Add("t1", parameterToString(*r.t1, ""))
	}
	if r.timespan != nil {
		localVarQueryParams.Add("timespan", parameterToString(*r.timespan, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("perPage", parameterToString(*r.perPage, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("startingAfter", parameterToString(*r.startingAfter, ""))
	}
	if r.endingBefore != nil {
		localVarQueryParams.Add("endingBefore", parameterToString(*r.endingBefore, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest struct {
	ctx context.Context
	ApiService *CapturesApiService
	organizationId string
	captureId string
	stopOrganizationDevicesPacketCaptureCapture *InlineObject261
}

func (r CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest) StopOrganizationDevicesPacketCaptureCapture(stopOrganizationDevicesPacketCaptureCapture InlineObject261) CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest {
	r.stopOrganizationDevicesPacketCaptureCapture = &stopOrganizationDevicesPacketCaptureCapture
	return r
}

func (r CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest) Execute() (*InlineResponse200278Items, *http.Response, error) {
	return r.ApiService.StopOrganizationDevicesPacketCaptureCaptureExecute(r)
}

/*
StopOrganizationDevicesPacketCaptureCapture Stop a specific packet capture (not supported for Catalyst devices)

Stop a specific packet capture (not supported for Catalyst devices)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param captureId Capture ID
 @return CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest
*/
func (a *CapturesApiService) StopOrganizationDevicesPacketCaptureCapture(ctx context.Context, organizationId string, captureId string) CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest {
	return CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		captureId: captureId,
	}
}

// Execute executes the request
//  @return InlineResponse200278Items
func (a *CapturesApiService) StopOrganizationDevicesPacketCaptureCaptureExecute(r CapturesApiStopOrganizationDevicesPacketCaptureCaptureRequest) (*InlineResponse200278Items, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse200278Items
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CapturesApiService.StopOrganizationDevicesPacketCaptureCapture")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/devices/packetCapture/captures/{captureId}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterToString(r.organizationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"captureId"+"}", url.PathEscape(parameterToString(r.captureId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.stopOrganizationDevicesPacketCaptureCapture == nil {
		return localVarReturnValue, nil, reportError("stopOrganizationDevicesPacketCaptureCapture is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stopOrganizationDevicesPacketCaptureCapture
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["bearerAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
